<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>作坊式写代码的危害</title>
      <link href="/2018/05/27/%E4%BD%9C%E5%9D%8A%E5%BC%8F%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%B1%E5%AE%B3/"/>
      <url>/2018/05/27/%E4%BD%9C%E5%9D%8A%E5%BC%8F%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%B1%E5%AE%B3/</url>
      <content type="html"><![CDATA[<p>自去年入行一直呆在小公司。由于忙于补知识，学新技术，平时写业务代码不是很讲究。这里说到小公司或者创业公司的一个特点：新人是没有人带的。所以我无形中变得很随意。</p><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>忙里偷闲</title>
      <link href="/2018/05/22/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B2/"/>
      <url>/2018/05/22/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B2/</url>
      <content type="html"><![CDATA[<p>因为处理社保的事，休了半天假，借这个时间梳理下最近心里所想。</p><a id="more"></a><h4 id="关于生活："><a href="#关于生活：" class="headerlink" title="关于生活："></a>关于生活：</h4><p>兜了一圈又回到了成都，为什么这么选择？无外乎这个地方有我惦记的人，同时我又是一个非常懒的人。考虑到国内恶劣的生存环境，总得找个地方落脚为以后留个后路。虽然我是个安徽人，看了一圈附近的城市，没有几个自己可以有一份好点的工作同时又能够安家的。再者，国内房价节节升高，普通人怎么抵御通胀呢？父母辛辛苦苦几十年挣的几十万血汗钱，购买力不知道打了几折了。能怎么办？？上车，为国接盘。希望我的选择是对的，当然也是对爱人负责。打算在成都买房不一定就意味着常住了，毕竟年纪还小，世界那么大，想看的东西太多。</p><h4 id="关于技术："><a href="#关于技术：" class="headerlink" title="关于技术："></a>关于技术：</h4><p>入行做的Java，虽然大学是计算机专业，实际上积累并不多。我是深刻认识到了这点，刚出来半年比较努力的去补一些东西，收获比较大。但是最近几个月有所松懈，直接表现为之前跳槽没有成功。（现在算是和原班人马出来创业了）面试暴露了太多问题：代码写的少了，源码分析的不够多，数据库知识欠缺，基础不够扎实，对项目的业务和技术难点理解不够透彻，对于这些问题要有针对的提高。</p><p>其实学技术对我来说最大的挑战不是说写多少代码，看多少书，而是发现越来越难平衡工作和生活的关系。一边要处理好工作的事，有点时间还要陪陪女朋友，偶尔也要偷懒。剩下的时间就不多了。之前看<code>鸟哥的Linux私房菜</code>这本书的时候，说到UNIX是怎么发明出来的。里面有个小故事说的是：作者的老婆去探亲了一个月，所以就有了UNIX的最初雏形。读到这我大笑，人人都有这个幸福的烦恼。显然这不是主要原因，即使老婆不去探亲，晚几天也能写完程序。牛人尚且如此！我更应该努力提升，让自己更加游刃有余。生活不仅仅是技术!</p><h4 id="想做的事，想去的地方"><a href="#想做的事，想去的地方" class="headerlink" title="想做的事，想去的地方"></a>想做的事，想去的地方</h4><p>想做不一样的工作：当然做技术的就是换个技术方向或者业务方向。想尝试做NodeJS，想去即刻（即刻app）想做社交。哈哈~ 付诸行动吧</p><p>想去的地方：由于我没去过的地方太多了，近期攒够钱了一定要出去走走。希望以后每年都能出去大玩几次。</p>]]></content>
      
      
        <tags>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>装饰模式</title>
      <link href="/2018/01/08/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/01/08/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>最近在梳理<code>IO</code>相关知识。众所周知，装饰模式大量运用在<code>Java</code>流的体系设计中。今天就简单的回顾下装饰模式的相关概念。<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>设计模式</code>中，装饰模式属于结构型模式，也就是说用来处理对象之间的关系。在面向对象程序设计中，处理对象间关系基本的手段包括<code>继承</code>，和<code>组合</code>。装饰模式就是典型的利用组合来达到对象关系处理和代码复用的目的。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>现在有一个抽象的<code>Person</code>类，需要设计出具有不同走路方式的<code>Person</code>实现类。很容易给出以下继承实现的解决方案：</p><p><img src="http://ospalociz.bkt.clouddn.com/9b2d97e2ed7342f385c26254fbfc34e4.png" alt="屏幕快照 2018-01-07 下午11.07.22.png"></p><p>每个具体人类的<code>run</code>方法中都调用了自己特有的方法比如<code>smile</code>,<code>talk</code>等。</p><p>在上面继承方案中有两个明显的问题：</p><ol><li>代码没有得到很好的复用，比如<code>Laura</code>想要<code>smile</code>和<code>talk</code>,除了自己声明其中一个方法，另一个继承。是没有办法多继承的。在<code>Java</code>中不允许多继承。</li><li>类的数量会越来越多。比如，要表示每个人所有可能行为的集合。这里有4个人定义了3种行为，最坏情况则需要28个类。</li></ol><p>这就是继承无法解决的问题，那么这个时候可以使用组合的方式来达到同样的目的，并且避免上面的问题。看下装饰模式的解决方案：</p><p><img src="http://ospalociz.bkt.clouddn.com/09eb384358ab4260b9b296821a60125f.png" alt="屏幕快照 2018-01-07 下午11.51.53.png"></p><p>在装饰模式中可以看到另一个实现了<code>Person</code>接口的分支。这是关键。<code>RunBehaviour</code>是一个抽象类，最为重要的是它持有了一个<code>Person</code>类型的引用，并且有一个接受<code>Person</code>类型的构造函数。<code>RunBehaviour</code>称之为装饰器，它的子类则是具体的<code>装饰器</code>。那些直接实现了<code>Person</code>接口的类则称之为具体的<code>构件类</code>。由于具体装饰器类和构件类实现了同样的接口。那么装饰器类就可以通过持有构件类使用自己特有的方法来对构建类进行增强，同时对外提供相同的接口。使用的时候就像使用原来构件类一样！</p><p>客户端代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person1,person2;</span><br><span class="line"></span><br><span class="line">person1 = <span class="keyword">new</span> <span class="type">Tom</span>();</span><br><span class="line"></span><br><span class="line">person2 = <span class="keyword">new</span> <span class="type">Talk</span>(person1);</span><br><span class="line"></span><br><span class="line">person2.run();</span><br></pre></td></tr></table></figure><p>这样<code>Tom</code>就可以在<code>run</code>的时候<code>talk</code>了。并且可以继续通过这种方式为<code>Tom</code>增加更多的行为。</p><h2 id="透明和半透明装饰模式"><a href="#透明和半透明装饰模式" class="headerlink" title="透明和半透明装饰模式"></a>透明和半透明装饰模式</h2><h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><p>像上面这种方式。我们要对构件类的原有方法进行增强。那么对于装饰过的类并没有特有的方法。一切的使用和接口里约定的一样，只不过方法被<code>装饰</code>了。客户端使用起来和原来构建类一样，感觉不到区别。</p><h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><p>有的时候我们需要单独调用装饰类中新增的方法，而不是在原有接口方法中调用。这个时候把装饰类声明为父类型，就会丢失访问特有方法的能力。那么只能把它声明为具体装饰类型。这个时候客户端就要关心这个区别了，所以称之为半透明。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：装饰模式很好的利用对象的组合来为对象增加职责，同时构件的变化和装饰器的变化互不影响。符合<code>开闭原则</code>。</li><li>缺点：对一个对象进行装饰的时候，会产生大量装饰类，增加使用复杂性。这也是<code>Java IO</code>令人疑惑的地方之一</li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于递归算法设计的思考</title>
      <link href="/2017/12/16/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2017/12/16/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>之前公司管理系统项目需要配合前端<code>VUE</code>实现动态路由，返回的数据结构是一个树形结构，但在数据库中存储的是平行的数据项。这个时候就需要在代码中去进行数据结构的组装。好久没思考这些问题，花了好些时间才搞定。这其中涉及到递归算法的实现，乘着周末深入的思考了下递归算法的设计，一点点拙见写下来做个笔记。<br><a id="more"></a></p><h3 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h3><p>对于<code>递归</code>其实我们并不陌生。还记得中学时代经常使用的<code>数学归纳法</code>？，<code>递归</code>其实并不是计算机科学独有的概念。实际上<code>数学归纳法</code>才是递归的理论基础。</p><p>先举个简单的栗子：求n! 这里使用递归来求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n*foo(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ospalociz.bkt.clouddn.com/66494249ea104641afe09888c25d15bc.svg" alt="栈.svg"></p><p>上面代码所表达的含义是：当<code>n</code>不等于<code>1</code>的时候。一直去调用<code>foo（n-1）</code>并且和传入的<code>n</code>相乘。在这里解释下递归调用的实现原理：我们知道计算机中函数的调用是使用栈的数据结构实现的，比如传入的<code>n</code>为<code>5</code>时，第一次执行<code>foo</code>方法，当执行到 <code>foo(n-1)</code>,方法<code>foo</code>会被压入栈中。其实递归方法的出栈入栈和普通方法是一样的。唯一的区别是递归调用的是自身的代码。这里不妨把<code>foo</code>的每次调用称作<code>foo1</code>,<code>foo2</code>等等。那么这样就好理解了，当<code>foo</code>方法执行到<code>n==1</code>的时候，栈里面依次存放着<code>foo1,foo2,foo3,foo4,foo5。</code>此时<code>foo5</code>在栈顶,出栈执行。<code>foo5</code>执行的时候<code>n==1</code>，由代码可知，<code>n==1</code>，方法直接返回<code>1</code>。接着<code>foo4</code>出栈，传入的<code>n</code>为<code>2</code>，运算<code>2*1</code>，然后<code>foo3,foo2,foo1</code>依次出栈，运算依次为：<code>3*2,4*6</code> 当最后一个方法<code>foo1 return</code>时计算，<code>5*24</code>，运行结束。</p><p>从这个过程中不难看出，递归是个不断下降的过程。层层调用自身，然后求值又是个上升的过程。从递归结束的出口返回值开始，层层向上求值。</p><p>从这个例子中还可以看出递归算法的两个重要特征，比如：</p><ol><li>不停调用自身</li><li>有终止的条件，不然就成了死循环了</li></ol><p>需要思考的问题是终止条件是如何确定的，以及他是怎么变化的。在上面的程序中是做<code>-1</code>操作。</p><h3 id="何时考虑使用递归呢？"><a href="#何时考虑使用递归呢？" class="headerlink" title="何时考虑使用递归呢？"></a>何时考虑使用递归呢？</h3><h4 id="当定义是递归时"><a href="#当定义是递归时" class="headerlink" title="当定义是递归时"></a>当定义是递归时</h4><p>和上面求阶乘的例子类型一样。<code>斐波那契数列</code>的定义就是递归的。直接看代码：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Fib(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line"><span class="built_in">if</span>(<span class="built_in">n</span>==<span class="number">1</span> || <span class="built_in">n</span>==<span class="number">2</span>) &#123;</span><br><span class="line">return <span class="number">1</span>;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">Fib(<span class="built_in">n</span>-<span class="number">1</span>)+Fib(<span class="built_in">n</span>-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>斐波那契数列</code> ： <strong>1,1,2,3,5 …</strong></p><h4 id="当数据结构本身是递归时"><a href="#当数据结构本身是递归时" class="headerlink" title="当数据结构本身是递归时"></a>当数据结构本身是递归时</h4><p>最常见的比如链表的定义（这里讨论的是没有头节点的链表）：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">private</span> <span class="keyword">String</span> data; //节点数据域</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">next</span>; //指向下一个节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要对链表数据域求和时,可以使用递归实现：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SUM(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">if(<span class="keyword">node</span> <span class="title">== null</span>) &#123;</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return <span class="keyword">node</span>.<span class="title">getData</span>()+SUM(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当问题需要用递归求解"><a href="#当问题需要用递归求解" class="headerlink" title="当问题需要用递归求解"></a>当问题需要用递归求解</h4><p><strong>这里详细讨论下汉诺塔算法的实现。</strong></p><blockquote><p>汉诺塔问题描述：有三个分别叫做X，Y，Z的塔座。在塔座X上有直径各不同，从小到大依次标号为：1，2，3…n的盘片，现在要求把塔座X上的盘片移动到塔座Z上，按相同顺序叠放。移动时需要遵守规则：1.每次只能移动一个盘片。 2.盘片可以放在任意一个塔座上。 3.不能将较大的盘片放在较小的上面。</p></blockquote><p>汉诺塔是典型的递归求解问题。光看描述不容易分析问题如何分解，不如在问题规模较小时，试着分析下解决方案。</p><p><strong>当X塔座上只有一个盘片时：</strong></p><p><img src="http://ospalociz.bkt.clouddn.com/a5363090f26846e4a4230eba51011348.png?imageView2/3/h/150" alt="2017-12-16 18.59.15.png"></p><p><code>X==&gt;Z</code></p><p><strong>当X塔座上有两个盘片时：</strong></p><p><img src="http://ospalociz.bkt.clouddn.com/eebe3ae6e806450d9783488842c3903f.png?imageView2/3/h/150" alt="2017-12-16 19.06.34.png"></p><p><code>X1==&gt;Y,X2==&gt;Z</code></p><p><img src="http://ospalociz.bkt.clouddn.com/e5f9650ee7084137b7e2cb0b69a7d171.png?imageView2/3/h/150" alt="2017-12-16 19.07.10.png"></p><p><code>Y1==&gt;Z</code></p><p><img src="http://ospalociz.bkt.clouddn.com/1efe61da98564f5fb183a191092d2343.png?imageView2/3/h/150" alt="2017-12-16 19.07.28.png"></p><p><strong>当X塔座上有三个盘片时：</strong></p><p><img src="http://ospalociz.bkt.clouddn.com/f679a158056f4c1bb4be44ee7012e776.png?imageView2/3/h/150" alt="2017-12-16 19.14.59.png"></p><p><code>X1==&gt;Z,X2==&gt;Y</code></p><p><img src="http://ospalociz.bkt.clouddn.com/d4d532f41c7e461f9908fb99e37f1ec0.png?imageView2/3/h/150" alt="2017-12-16 19.16.36.png"></p><p><code>Z==&gt;Y,X==&gt;Z</code></p><p><img src="http://ospalociz.bkt.clouddn.com/624a4d7cf1cf4fc3889ab00a5d088a6d.png?imageView2/3/h/150" alt="2017-12-16 19.17.01.png"></p><p><code>Y1==&gt;X,Y2==&gt;Z</code></p><p><img src="http://ospalociz.bkt.clouddn.com/1c52059f2f264dd9876511ed0413e9cb.png?imageView2/3/h/150" alt="2017-12-16 19.17.33.png"></p><p><code>X==&gt;Z</code></p><p><img src="http://ospalociz.bkt.clouddn.com/a7433272c6b441f7abb8cbff2c3fcc7f.png?imageView2/3/h/150" alt="2017-12-16 19.17.55.png"></p><p>先给出递归算法，这个算法将打印出移动的步骤。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hanoi(<span class="keyword">int</span> n,<span class="keyword">String</span> X,<span class="keyword">String</span> Y,<span class="keyword">String</span> Z) &#123;</span><br><span class="line"><span class="built_in">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"将第"</span>+n+<span class="string">"个盘片从"</span>+X+<span class="string">"移到"</span>+Z); <span class="comment">//X==&gt;Z</span></span><br><span class="line">&#125;<span class="built_in">else</span> &#123;</span><br><span class="line">Hanoi(n<span class="number">-1</span>,X,Z,Y);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"将第"</span>+n+<span class="string">"个盘片从"</span>+X+<span class="string">"移到"</span>+Z); <span class="comment">//X==&gt;Z</span></span><br><span class="line">Hanoi(n<span class="number">-1</span>,Y,X,Z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汉诺塔的基本要求是要把最大的放在最下面,所以当<code>X</code>塔座上的盘片数量大于1时，我们首先要把<code>X</code>塔座上，<code>1至n-1</code>的盘片放到<code>Y</code>上，于是我们可以忽略<code>X</code>最下面的盘片，把<code>Y</code>当做<code>Z</code>，<code>Z</code>当做<code>Y</code>，这样问题回到了，当<code>X</code>有<code>n-1</code>个盘片，如何移动到<code>Z</code>的情形。记住这个时候的<code>Z</code>是<code>Y</code>。 现在我们已经做到了把<code>X</code>上<code>1至n-1</code>的盘片放到了<code>Y</code>上。别忘了<code>X</code>上还有一个我们忽略的最大盘片。</p><p>好，现在把<code>X</code>最大盘片放到<code>Z</code>，这个时候<code>X</code>没有盘片，<code>Y</code>有<code>1至n-1</code>的盘片，现在我们忽略<code>Z</code>上的最大盘片。将<code>Y</code>当做<code>X</code>，<code>X</code>当做<code>Y</code>。问题又回到了<code>X</code>上有<code>n-1</code>个盘片如何移动到<code>Z</code>的情形。</p><blockquote><p>再看上面给出的代码。当<code>n==1</code>时，直接把<code>X</code>移到<code>Z</code>，否则，将<code>Y</code>当做<code>Z</code>，<code>Z</code>当做<code>Y</code>，将<code>1至n-1</code>盘片移到<code>Y</code>上。这个时候取出<code>X</code>最大盘片放到<code>Z</code>。再把<code>X</code>当<code>Y</code>，<code>Y</code>当做<code>X</code>，继续递归。直到<code>n==1</code>，移动成功！其实不难发现当执行到第二个<code>System.out.println(&quot;将第&quot;+n+&quot;个盘片从&quot;+X+&quot;移到&quot;+Z);</code>时。已经完成了将<code>X</code>的最大盘片移到<code>Z</code>的目标。汉诺塔的层数减一。问题回到了最初的情形，只不过，盘片在<code>Y</code>上，不在<code>X</code>上。但是这不妨碍调用<code>Hanoi</code>方法。实际上问题的关键在于，<code>X，Y，Z</code>三个塔座没有区别是一样的。还有一轮操作完之后，只是把最下面的盘片放到了<code>Z</code>，这个时候问题的规模就减一了。</p></blockquote><h3 id="如何设计递归算法？"><a href="#如何设计递归算法？" class="headerlink" title="如何设计递归算法？"></a>如何设计递归算法？</h3><h4 id="找出递归结束条件"><a href="#找出递归结束条件" class="headerlink" title="找出递归结束条件"></a>找出递归结束条件</h4><p>上文总结的递归特征中，有一条说明了递归必须要有终止条件。比如求阶乘，斐波那契数列以及汉诺塔问题，它们在递归调用时表示问题规模的<code>n</code>一直在递减，直到达到递归结束条件<code>n==1</code>。实际上，递归条件不一定是这种通过递减来达到结束条件判断值的，比如在构造树形结构的时候，可以通过判断数据项的<code>isLeaf</code>字段是否为<code>true</code>来决定是否退出递归。有一点可以肯定的是，递归退出条件一定隐藏在初次调用传入方法的参数中以及一切在方法运行时可以访问的状态。</p><h4 id="找出循环体"><a href="#找出循环体" class="headerlink" title="找出循环体"></a>找出循环体</h4><p>这是一个比较难的问题，对于类似数学定义问题，循环体往往就是定义问题的那几句话，比如斐波那契数列的定义：<code>当0&lt;n&lt;3时，Fib=1，当n&gt;2时，Fib(n)=Fib(n-1)+Fib(n-2)</code>。当为递归数据结构设计算法时，循环体则是访问递归结构的指令。比如遍历链表时：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">if</span>(<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</span><br><span class="line">foo(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是像汉诺塔这类问题，直观上没办法直接看出递归的特征。个人经验则是在较小问题规模上，进行演算。发现递归特征。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>递归程序设计本身是比较难以理解和掌握的，通过简单的理论学习无法熟练运用，只有不断的解决问题才会熟能生巧。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解进程和线程</title>
      <link href="/2017/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2017/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>前段时间一直在研究多线程相关的东西，乘着时间多又回顾了下操作系统关于进程和线程的知识。<br><a id="more"></a></p><h4 id="必须要明确的概念"><a href="#必须要明确的概念" class="headerlink" title="必须要明确的概念"></a>必须要明确的概念</h4><p>进程和线程是一种<code>资源</code>,动态的存在于系统中。从实现上来看进程是一种数据结构，是静态的概念。通常一个进程对应于系统中活动的程序。</p><h4 id="进程是用来干嘛的？"><a href="#进程是用来干嘛的？" class="headerlink" title="进程是用来干嘛的？"></a>进程是用来干嘛的？</h4><p>我们知道在早期的计算机操作系统中，<code>cpu</code>一次只能执行一个任务。所以我们不能一边处理文档，一边听音乐。随着人们对多任务的需求，能够同时处理多个程序的操作系统应运而生。当然这里的同时是假的，在单核<code>cup</code>中，是通过<code>时分复用</code>来制造多任务处理的假象。（多核cup中才得以真正的并行，单核只是并发）要设计这样一个操作系统，首当其冲要解决的问题就是：<code>用什么样的一个概念来刻画同时执行的程序？</code>于是便出现了进程。可以说进程就是为了刻画程序的<code>并发性</code>而存在的，同时又共享了系统的资源。前面提到了，进程和线程本质上是一种资源。</p><h4 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h4><p>操作系统在引入进程后，不得不付出一定的代价，因为需要对其进行调度，管理。正是操作系统不断的调度进程才让不同的程序可以占用<code>cpu</code>资源，得到执行。这里有个理解上的误区，也是一直在强调的，即进程不是程序。很多人会把进程理解为程序。<code>实际上是程序占用了进程</code>。进程是动态的概念，程序是静态的概念。虽然平时提到程序时大都在指运行中的程序。</p><p>既然进程需要被调度，那么自然会有多种状态，操作系统的调度会让进程在这些状态中转换。简单介绍下进程运行的<code>三态模型</code>和<code>七态模型</code>。</p><p><em>三态模型</em></p><p><img src="http://ospalociz.bkt.clouddn.com/bb6f285214384407959de0cb837289e6.svg" alt="三态模型.svg"></p><p>三态模型假设进程被创建出来时是就绪状态等待被调度执行，当遇到等待事件时暂停执行，最终因为事件结束再一次处于就绪状态，等待操作系统调度。显然这个模型只表达了最基本的状态，不符合实际调度需求。</p><p><em>七态模型</em></p><p><img src="http://ospalociz.bkt.clouddn.com/a0d21d685a0d47e8824982b9d3a45ce1.svg" alt="七态模型.svg"></p><p>对于进程的调度来说，七态模型更加符合要求。比如进程刚被创建出来还为分配资源的时候处于<code>新建态</code>，当操作系统各项准备工作完毕，则进入<code>就绪态</code>。值得注意的是：这里出现了挂起的状态，此状态表达的意思是，当内存资源不够用时，一些进程往往会被对换到磁盘上去，也就是外存。</p><h4 id="如何描述进程"><a href="#如何描述进程" class="headerlink" title="如何描述进程"></a>如何描述进程</h4><p>前面提到了进程是一种数据结构，那么需要用什么样的一种数据结构来描述进程呢？这里不去深究具体某种操作系统进程的实现，试着分析下进程需要包括哪些必要的信息。首先进程需要被调度执行，所以必须有一个相应的结构存储进程的标志信息，称之为<code>控制块</code>（PCB,Process Control Block）。其次进程需要执行程序，所以有专门存放代码的<code>程序块</code>，进程运行程序以及本身都要存放一些数据，所以存在一个私有<code>数据块</code>。在<code>数据块</code>中可以开辟用户运行程序的<code>用户栈</code>。于此同时，进程又必须拥有一个核心栈，用于在<code>内核态</code>执行内核程序。</p><p>有关<code>用户态</code>和<code>内核态</code>的区别可以参考这篇文章<a href="https://yq.aliyun.com/articles/6033" target="_blank" rel="noopener">内核态和用户态的区别</a></p><p>到这里，从概念上了解了进程的基本组成。对于简单理解进程是什么已经足够了。</p><h4 id="如何调度进程"><a href="#如何调度进程" class="headerlink" title="如何调度进程"></a>如何调度进程</h4><p>一般来说，操作系统会在不同的层次上对整个系统中运行的进程进行调度，最低一层次则是直接决定哪个进程的状态。通常所说的调度实际上包括：决定进程使用cpu的次序以及进程的切换工作。这里集中关注下如何判定进程执行次序，即调度算法。</p><h5 id="常见的几种调度算法"><a href="#常见的几种调度算法" class="headerlink" title="常见的几种调度算法"></a>常见的几种调度算法</h5><ol><li>先来先服务算法</li><li>最短优先算法</li><li>最短剩余时间算法</li><li>最高响应比算法</li><li>优先级调度算法</li><li>轮转调度算法</li><li>多级反馈队列调度算法</li></ol><p>低级调度主要决定就绪进程或线程队列中哪一个可以立即占用处理器执行，执行的非常频繁。一般来说调度分为<code>抢占型</code>和<code>独占型</code>。内核关键程序使用<code>独占型</code>，普通的则采用<code>抢占型</code>，虽然后者更消耗系统资源，但是并发程度更高，使得性能更好。</p><p>这里简单介绍下<code>多级反馈队列调度算法</code>。MLFQ算法的核心思想是：建立多个优先级不同的等待队列，对列的优先级可以事先确定。优先级越高的队列的进程或线程优先被调度执行，但是优先级越高所分得的时间片就越少。优先级最低的队列会按照先来先服务算法调度。当一个耗时较多的进程或线程没有在所分得的时间片内执行完，那么它就会被加入到下一级队列。一直到最低一级。大家可能会注意到这样可能会产生<code>饥饿</code>的现象。比如一个特别耗时的进程，它最终会来到最低级队列，如果系统一段时间内有源源不断的进程被加入进来。那么这个进程就不会得到执行。怎么办呢？？我们可以按等待时间让进程的优先级升高。这就形成了一个反馈机制。系统根据这个算法就能够比较合理的进行进程/线程的调度。</p><h4 id="进程上下文切换和处理器状态转换"><a href="#进程上下文切换和处理器状态转换" class="headerlink" title="进程上下文切换和处理器状态转换"></a>进程上下文切换和处理器状态转换</h4><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>前面一直提到进程/线程的调度，实际上没有想象的把进程/线程队列入队，出队那么简单。一个进程放弃执行权利，把cpu让给另一个进程还要进行很多其他操作。统称为上下文（context）的切换。简单来说需要进行两个步骤：</p><ol><li>将当前进程/线程的运行相关的信息保存下来，可以理解为保存现场，并移入等待队列。</li><li>调度一个就绪进程/线程占有cpu执行程序。</li></ol><h4 id="处理器状态转换"><a href="#处理器状态转换" class="headerlink" title="处理器状态转换"></a>处理器状态转换</h4><p>与进程上下文切换有关的是处理器状态转换，值得注意的是，处理器状态的转换不一定会引起进程上下文的切换。比如发生了系统中断，那么这个时候处理器会从用户态转化到内核态去处理中断处理程序，此时还是在进程的上下文中。然后可以恢复到用户态再继续执行进程。我的理解是：进程上下文切换是进程之间的事情，进程的上下文实际上是开辟在用户空间的。虽然执行中断或者内核例程也暂停了当前进程的执行，但是并不会破坏进程的上下文。因为中断或例程的上文是存在于内核空间的。</p><h4 id="为什么要引入线程"><a href="#为什么要引入线程" class="headerlink" title="为什么要引入线程"></a>为什么要引入线程</h4><blockquote><p>如果说操作系统引入进程的目的是使得多个程序可以并发执行，提高系统资源利用率，那么线程就是为了让进程切换的代价更低，并发的粒度更细，进一步提高系统效率。实际上在现代操作系统中，例如<code>Linux</code>，线程是操作系统直接调度的最小单位，而进程作为资源分配和保护的基本单位。一个进程至少包括一个主线程。</p></blockquote><h4 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h4><p>与进程不同的是线程不拥有资源，它是一条程序的执行路径，拥有自己的私有地址空间和程序计数器。暂停时会保存自己的运行上下文。一个进程中的线程通常共享内部资源，所以线程间的通信要容易的多。多线程进程实际上和线程是包含的关系。进程像一个大管家一样，为线程服务：提供虚拟的地址空间，提供全局数据的管理等等。线程的职责更少，所以更加轻量。同处于一个进程中的线程切换的成本更低，大大提高了并发度。</p><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>多线程的实现分为三类：内核级线程（Kernel Level Thread ,KLT），用户级线程（ULT）,混合式线程。个人水平有限，大家可以通过这篇文章 <a href="http://www.linuxidc.com/Linux/2016-09/135308.htm" target="_blank" rel="noopener">Java实现线程的三种方式</a>了解下Java多线程的实现原理。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在简单了解了进程和线程的相关知识后，后面会着重探讨下并发程序设计中，同步，通信和死锁的问题。</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java的异常处理机制-续、</title>
      <link href="/2017/08/26/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-%E7%BB%AD%E3%80%81/"/>
      <url>/2017/08/26/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-%E7%BB%AD%E3%80%81/</url>
      <content type="html"><![CDATA[<p>在<a href="http://www.xiaqiguo.com/articles/2017/08/20/1503226655149.html" target="_blank" rel="noopener">上一篇</a>中简单介绍了异常的概念和基本的使用方法。本篇将继续深入了解异常的使用原则。<br><a id="more"></a></p><h4 id="使用finally"><a href="#使用finally" class="headerlink" title="使用finally"></a>使用finally</h4><p>在使用<code>finally</code>时有一些陷阱是需要注意的。我们知道无论是否发生异常<code>finally</code>代码块始终都会被执行。考虑一种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能产生异常的代码块</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line"><span class="comment">//捕获异常后的动作</span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时在<code>try</code>块和<code>finally</code>块中存在<code>return</code>语句究竟谁会被返回呢？直觉告诉我们好像<code>try</code>中的<code>return</code>执行后方法就结束了吧，应该返回<code>try</code>中的。但是实际上并不是这样，根据<code>finally</code>的用法，最终<code>finally</code>中的返回值将会覆盖<code>try</code>中的返回值（实际验证确实如此）。</p><p>根据上面的经验考虑这种情况：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>异常信息在没有得到处理的情况下丢失了。</code></p><h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为<code>异常链</code>。</p><p><strong>重新抛出异常</strong></p><p>有的时候我们希望重新抛出异常:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> e)&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">throw</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想将异常抛出点更新为当前方法，可以调用异常的<code>fillInStackTrace()</code>方法，像这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> e)&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">throw</span> (<span class="keyword">Exception</span>)e.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者抛出新的异常</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">//抛出新的异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyException</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的异常信息丢失了。如果想把之前的异常信息保存下来（保存到新的异常对象中），所有的<code>Throwable</code>的子类在构造器中都可以接受一个<code>cause</code>对象作为参数(<code>cause</code>是<code>Throwable</code>类型的)，这个<code>cause</code>就是用来表示原始异常，这样通过把原始异常传递给新的异常，使得我们可以追踪到异常最初发生的地方。</p><p>但是在<code>Throwable</code>子类中只有三种基本异常提供了带<code>cause</code>参数的构造器。<code>Error</code>（<code>JVM</code>报告系统错误），<code>Exception</code>，<code>RuntimeException</code>。如果要把其他异常链接起来需要使用<code>initCause()</code>方法而不是构造器。下面是一个示例：</p><p><strong>使用构造器：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyException</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span> (MyException e)&#123;</span><br><span class="line">RuntimeException e1 = <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line"><span class="keyword">throw</span> e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用<code>initCause()</code>方法</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line"><span class="comment">//抛出新的异常保存原来的异常信息</span></span><br><span class="line">MyException myException = <span class="keyword">new</span> <span class="type">MyException</span>();</span><br><span class="line">保存原来的异常信息</span><br><span class="line">   myException.initCause(e);</span><br><span class="line">   <span class="keyword">throw</span> myException; <span class="comment">//这个异常捕获或者抛出它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h4><blockquote><p><code>throws</code>关键字</p></blockquote><p>异常声明在不希望本层处理异常的时候把异常信息向上抛出，由上层代码处理（层层抛出则最终会抛到<code>JVM</code>）。我们在设计抽象层或者类库的时候常常可以在方法后抛出需要处理的异常。这也是使用者需要遵守的约定之一。</p><p><code>异常声明本身不属于方法说明的一部分，方法类型是由方法的名字和参数类型组成的（实际上返回值类型也属于方法的组成，所谓方法签名，但是重载只根据方法名和参数列表）。所以不能基于异常声明来重载方法。</code></p><p><strong>在继承体系中使用异常应该注意什么？</strong></p><p>当覆盖方法或实现接口时只能抛出在基类方法（接口方法）的异常声明中列出的异常。为什么这样呢？我们要理解在方法声明中的异常信息是使用者（子类，实现类）需要遵守的约定之一，你必须处理（抛出）这些没有被处理的异常。所以在继承体系中，异常通常是越抛越少的（因为每层几乎都会处理掉一些）。与之形成对比的是：继承体系中类的方法和数据域往往是越来越丰富的。还有一点:这保证了子类的可替换性，是面向对象的特性。（如果没有这个限制，当替换子类或实现类时，代码将变的不可用，因为异常是不确定的）</p><p><strong>构造器中抛出的异常</strong></p><p>在继承体系中，派生类的构造器可以抛出任何异常而不受基类构造器异常的限制，但是必须包括基类抛出的异常。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">public <span class="type">A</span>()<span class="keyword">throws</span> <span class="type">MyException1</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">public <span class="type">B</span>() <span class="keyword">throws</span> <span class="type">MyException1</span>,<span class="type">MyException2</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类构造器不能捕获基类构造器抛出的异常。(捕获异常需要用<code>try</code> <code>catch</code> 语句包含，但是调用父类构造器的语句必须要在第一行，显然原则相互违背，编译不会通过)我们知道当类的对象被创建时会依次调用其所有基类的构造器。显然在派生类中捕获基类异常是没有意义的，因为对象创建已经在某个基类中失败了，每个构造器应该只关注自己的行为，如果子类构造器干涉了父类构造器抛出异常信息，那么就不能准确判断创建过程中发生的事了。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>不应该在异常没有处理的情况下再抛出新的异常，这样原来的异常信息就会丢失。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException<span class="number">1</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异常发生时是不是所有的东西都可以被正确清理？像打开一个文件，获取一个数据库连接这样的操作，需要保证资源最终被释放。但是如果一开始就获取失败呢？考虑下面的这种情况：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>in</code>没有被创建，关闭操作将会失败。改变一下，需要一点点技巧</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>in</code>没有被正确创建，则会进入外层的<code>catch</code>，嵌套逻辑保证了当内层发生异常时，<code>in</code>一定被创建了。</p><h4 id="关于未检查异常"><a href="#关于未检查异常" class="headerlink" title="关于未检查异常"></a>关于未检查异常</h4><p>未检查异常（<code>RuntimeException</code>）是不受检查的异常，意思是编译器不会对它进行警告，它属于<code>运行时异常</code>。这种异常实际上是一种错误（这里说的错误指的是应用运行层面的编程错误），比如<code>NullPointerException</code>空指针异常，它是继承自<code>RuntimeException</code>，想象一下程序在运行过程中某个变量极有可能为空（原因可能是传入参数为空），而导致调用失败，这个时候就需要抛出异常来报告错误。但是在代码编写和编译阶段无法确定异常是否会发生，那么我们就要在每个可能的地方加上异常处理代码，这是相当可怕的。幸运的是<code>JVM</code>为我们处理了这类<code>运行时异常</code>，使我们不必操心运行时的事情。当然你也可以主动抛出<code>RuntimeException</code>或者捕获它。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java的异常处理机制</title>
      <link href="/2017/08/20/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/08/20/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>异常从字面上理解就是一种意外的情况，对于程序而言则是出现了错误，比如执行到某一句无法进行下去了。但是这样说并不是很准确，从更高的层面来看，其实异常的字面含义就是它的设计思想：一切不正常的状态都可以归为异常，不一定是程序代码或逻辑的错误，也可以是人为定义的错误状态，当然这涉及到具体处理事务的逻辑。在<code>Java</code>中异常是一种错误报告机制，我们可以定义异常，亦可以决定如何报告。<br><a id="more"></a></p><h4 id="程序如何处理错误"><a href="#程序如何处理错误" class="headerlink" title="程序如何处理错误"></a>程序如何处理错误</h4><p>在一些早期的语言中例如<code>C</code>，使用约定的方式来处理错误。通常由程序员自行定义错误，然后自行处理。非常典型的例子是通过返回状态码来确定执行状态。虽然也可以奏效，但是存在如下几个问题：</p><ol><li>没有统一的规范。</li><li>非强制性。</li><li>错误处理代码和正常代码紧密耦合。</li><li>程序员需要考虑太多错误处理情况。</li></ol><p>在产生问题后，通常我们就打开<code>debug</code>工具去查找问题，因为通过这些状态码实在看不出来问题出在哪里。</p><p>于是语言设计者们考虑到要将错误处理的方式统一到语言特性中去，强制所有的人使用一种错误处理机制，以增加程序的鲁棒性。<code>Java</code>并不是第一个采用异常机制的语言，它从其他的语言中借鉴了许多。</p><h4 id="终止模型与恢复模型"><a href="#终止模型与恢复模型" class="headerlink" title="终止模型与恢复模型"></a>终止模型与恢复模型</h4><blockquote><p>异常处理理论上有两种基本的模型。Java支持终止模型。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回。</p></blockquote><blockquote><p>另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。恢复模型希望异常被处理后能继续执行程序。比如操作系统通常都支持恢复模型，当程序崩溃时会<br>试图恢复程序的运行。</p></blockquote><h3 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h3><p><img src="http://ospalociz.bkt.clouddn.com/308af954b48b470f872b13ca2a97e34e.jpeg?imageView2/3/h/400" alt="Java异常体系简图"></p><p>从这张图中可以看出所有的错误信息是从一个叫做<code>Throwable</code>的类继承而来，然后分为<code>Error</code>和<code>Exception</code>。<code>Error</code>是不用程序员去关心的就像它的名字一样，代表着系统层面的错误，交给JVM去处理就好了，我们需要关心的就是<code>Exception</code>，以及它的各个子类。值得注意的是在<code>Exception</code>子类中有一类异常叫做<code>RuntimeExcetion</code>（运行时异常）。在Java中这类异常通常被称作未检查异常，意思是编译器不会强制你对它进行处理。而其他从<code>Exception</code>派生的异常则必须对其进行处理，否则无法编译通过。</p><h3 id="使用异常处理错误"><a href="#使用异常处理错误" class="headerlink" title="使用异常处理错误"></a>使用异常处理错误</h3><p>在<code>Java</code>中我们使用这样的语法捕捉异常：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="string">//</span>可能产生异常的代码块</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;catch<span class="params">(MyException e)</span>&#123;</span><br><span class="line"><span class="string">//</span>捕获异常后的动作</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"><span class="string">//</span>无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>finally</code>是可选的。</strong></p><p>也可以有多个<code>catch</code>：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="string">//</span>可能产生异常的代码块</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;catch<span class="params">(MyException e)</span>&#123;</span><br><span class="line"><span class="string">//</span>捕获异常后的动作</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;catch<span class="params">(Exception e)</span>&#123;</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"><span class="string">//</span>无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时需要依照异常的关系(通常包括继承关系)把<code>catch</code>子句排序，最终处理异常的子句是按顺序匹配的，一旦前一个匹配，后面的都不会执行。</p><p>或者没有<code>catch</code>但是必须有<code>finally</code>：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="string">//</span>可能产生异常的代码块</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"><span class="string">//</span>无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时需要将异常抛出<code>throws</code>下面会讲解它的用法。这种语法逻辑的意义在于，抛出异常的方法总是将清理的工作完成了。接受异常的方法则只需要关心异常的处理，实现了<code>职责分离</code>。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>我们可以通过继承Exception来实现自己的异常，就像这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">       <span class="comment">//你也可以不提供这样的带参构造器，因为一般通过名字就可以知道是什么异常</span></span><br><span class="line">       public <span class="type">MyException</span>(<span class="type">String</span> msg) &#123;</span><br><span class="line">           <span class="keyword">super</span>(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后使用它：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[]args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"MyException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException e)&#123;</span><br><span class="line">            e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.xiaqiguo</span><span class="selector-class">.impl</span><span class="selector-class">.MyException</span>: MyException</span><br><span class="line">at com<span class="selector-class">.xiaqiguo</span><span class="selector-class">.impl</span><span class="selector-class">.TestException</span><span class="selector-class">.main</span>(TestException<span class="selector-class">.java</span>:<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>当然也可以在异常中记录一些信息，或者把异常信息输出到日志系统中。在实际应用中，异常是给大家使用的，所以记录日志的动作一般放在抛出异常的层面。</p><h4 id="使用finally"><a href="#使用finally" class="headerlink" title="使用finally"></a>使用finally</h4><p>在使用<code>finally</code>时有一些陷阱是需要注意的。我们知道无论是否发生异常<code>finally</code>代码块始终都会被执行。考虑一种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能产生异常的代码块</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line"><span class="comment">//捕获异常后的动作</span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时在<code>try</code>块和<code>finally</code>块中存在<code>return</code>语句究竟谁会被返回呢？直觉告诉我们好像<code>try</code>中的<code>return</code>执行后方法就结束了吧，应该返回<code>try</code>中的。但是实际上并不是这样，根据<code>finally</code>的用法，最终<code>finally</code>中的返回值将会覆盖<code>try</code>中的返回值（实际验证确实如此）。</p><p>根据上面的经验考虑这种情况：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息在没有得到处理的情况下丢失了。</p><h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>在捕获到一个异常后,我们常常会抛出另一个异常（抛出后异常的发生地点就变成了），但是希望把原有的异常信息保存下来。</p><h4 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h4><p>当我们不想在此处处理异常时就需要把它交给上级处理，叫做抛出<code>throws</code>，由于这些动作写在方法上，更像是一种声明。例如：<code>void f() throws MyException1,MyException2{...}</code>如果没有throws声明，则此方法不会抛出除<code>RuntimeException</code>外的其他异常。</p><p><strong>子类覆盖父类</strong></p><p>子类覆盖父类时只能抛出父类方法中异常声明里包含的异常。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>不应该在异常没有处理的情况下再抛出新的异常，这样原来的异常信息就会丢失。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException<span class="number">1</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异常发生时是不是所有的东西都可以被正确清理？像打开一个文件，获取一个数据库连接这样的操作，需要保证资源最终被释放。但是如果一开始就获取失败呢？考虑下面的这种情况：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>in</code>没有被创建，关闭操作将会失败。改变一下，需要一点点技巧</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>in</code>没有被正确创建，则会进入外层的<code>catch</code>，嵌套逻辑保证了当内层发生异常时，<code>in</code>一定被创建了。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式之抽象工厂</title>
      <link href="/2017/08/05/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
      <url>/2017/08/05/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
      <content type="html"><![CDATA[<p>在<a href="http://www.xiaqiguo.com/articles/2017/07/30/1501428222613.html" target="_blank" rel="noopener">简单工厂</a>中我们解耦了对象创建职责和使用职责，将对象的创建分离到工厂类中，随之产生的问题是对象创建逻辑集中在一起并且越来越复杂，难以维护。为了解决这个问题，引入了<a href="http://www.xiaqiguo.com/articles/2017/08/01/1501596290090.html" target="_blank" rel="noopener">抽象工厂</a>的概念。即由抽象工厂统一对象创建行为，具体工厂负责创建每一种产品。在这种模式下，创建逻辑被分散到各个具体工厂中。但是问题又来了，随着产品的增多，工厂类和产品类成对增加。系统中增加了大量的类，导致系统越来越庞大和复杂，难以维护！<br><a id="more"></a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>前面提到的类数量激增问题是<a href="http://www.xiaqiguo.com/articles/2017/08/01/1501596290090.html" target="_blank" rel="noopener">工厂方法模式</a>的主要缺陷，那么有什么好的办法解决呢？在原来的工厂类中只存在一个或一组重载的对象创建方法，现在我们可以考虑将相关产品的创建放在一个工厂类中，这样一来工厂类的数量就会大大减少。什么是相关产品呢？这里要提一个产品族的概念。比如电脑相关的产品，有主机，显示器，键盘，鼠标。主机有很多品牌，显示器也有很多品牌，键盘鼠标同理。那么要生产一个电脑出来，就需要从这四个产品中各选一个品牌出来，这就是一个产品族。对应到工厂类就是具有产生这一组产品的方法。</p><p>简单代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *抽象产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">MainFrame</span> &#123;&#125; <span class="comment">//主机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Displayer</span> &#123;&#125; <span class="comment">//显示器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Keybord</span> &#123;&#125; <span class="comment">//键盘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Mouse</span> &#123;&#125; <span class="comment">//鼠标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Factory</span> &#123;</span><br><span class="line"><span class="comment">//主机</span></span><br><span class="line"><span class="function">MainFrame <span class="title">getMainFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//显示器</span></span><br><span class="line"><span class="function">Displayer <span class="title">getDisplayer</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//键盘</span></span><br><span class="line"><span class="function">Keybord <span class="title">getKeybord</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//鼠标</span></span><br><span class="line"><span class="function">Mouse <span class="title">getMouse</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">Factory lenovoFactory = <span class="keyword">new</span> LenovoFactory(); <span class="comment">//获取一个联想电脑工厂</span></span><br><span class="line"><span class="comment">//获取一组联想电脑组件，组成一台电脑</span></span><br><span class="line">lenovoFactory.getMainFrame();</span><br><span class="line">lenovoFactory.getDisplayer();</span><br><span class="line">lenovoFactory.getKeybord();</span><br><span class="line">lenovoFactory.getMouse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里省略了具体产品实现和工厂类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象工厂模式可以说是工厂方法模式在具体场景下的延伸。由于它提供了更为强大的工厂类并且具备较好的扩展性，在软件开发中得到了广泛的应用，尤其是在一些框架和<code>API</code>类库的设计中例如<code>AWT</code>（<code>Java</code>抽象窗口工具包）。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>抽象工厂模式可以保证系统在同一时刻使用的是一组相关的对象，而且在系统中增加一组相关对象以及对应工厂无需修改原有代码，符合<code>开闭原则</code>，但是当修改产品族时不得不对抽象代码修改。所以抽象工厂模式适用于产品结构稳定的系统。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式之工厂方法</title>
      <link href="/2017/08/01/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
      <url>/2017/08/01/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在<a href="http://www.xiaqiguo.com/articles/2017/07/30/1501428222613.html" target="_blank" rel="noopener">工厂模式之简单工厂</a>中介绍了什么是工厂模式以及为什么要使用工厂模式，最后给出了简单工厂的一个示例，解决了在面向对象设计中对象创建与对象使用职责耦合的问题，但是新的问题又来了:<strong>当系统中需要引进新的实现时，由于静态工厂方法通过传入不同参数的方式来返回不同的实现，这必定要修改工厂类的代码，违反了<code>开闭原则</code>。如何在不修改现有代码的前提下增加新的实现？工厂方法模式应运而生</strong>。<br><a id="more"></a></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>既然一个工厂满足不了需求，那么就来多个工厂吧，这样一来就不用修改工厂类代码了。但是这些工厂应该具有一致的行为:创建对象，所以给它们一个共同的父类或者接口，这里我们定义一个接口。看下面的示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Product</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Factory</span> &#123;</span><br><span class="line"><span class="function">Product <span class="title">getProduct</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个产品接口用于表示产品的抽象层次。它的实现分别为<code>ProductA</code>，<code>ProductB</code>…,在<a href="http://www.xiaqiguo.com/articles/2017/07/30/1501428222613.html" target="_blank" rel="noopener">上篇文章</a>中使用<code>A</code>，<code>B</code>，<code>C</code>来表示类不是很好，不利于理解。对于工厂来说首先想到的是它能生产产品。</p><p>在<a href="http://www.xiaqiguo.com/articles/2017/07/30/1501428222613.html" target="_blank" rel="noopener">简单工厂</a>中把类的创建逻辑都放在一个方法中，现在我们来把它分散在不同的工厂实现中，就像这样：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Factory</span></span> </span>&#123;</span><br><span class="line">Product getProduct()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Factory</span></span> </span>&#123;</span><br><span class="line">Product getProduct()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Factory factoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">Product productA = FactoryA.getProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候如果我们要增加新的具体产品，只需要实现好新的产品，在新的工厂类中生产它就行了。不需要修改原有代码，符合<code>开闭原则</code>。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>新的问题又来了，如果新产品不断增多，工厂类的数量也随之增加。导致系统内激增大量的类，增加了系统的复杂性和维护难度。有没有更好的办法来解决呢？</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式之简单工厂</title>
      <link href="/2017/07/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
      <url>/2017/07/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
      <content type="html"><![CDATA[<p>工厂模式分为<strong>简单工厂模式</strong>，<strong>工厂方法模式</strong>，<strong>抽象工厂模式</strong>。复杂度由低到高，分别解决了不同场景下<strong>对象创建</strong>的问题。<br><a id="more"></a></p><h3 id="为什么需要工厂模式？"><a href="#为什么需要工厂模式？" class="headerlink" title="为什么需要工厂模式？"></a>为什么需要工厂模式？</h3><p>很多时候我们通过反射就可以非常灵活的创建对象，那么为什么还要使用工厂模式？在<code>Java</code>中创建对象的方法通常有以下几种：</p><ol><li>通过<code>new</code>关键字直接创建对象。</li><li>通过<code>反射</code>创建对象。</li><li>通过<code>clone</code>创建对象。</li><li>通过<code>工厂模式</code>创建对象。</li></ol><p>通过new关键字来创建对象虽然很方便但是灵活性很差，考虑一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="comment">//声明一个B类型的对象，其拥有method方法</span></span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line"><span class="comment">//类初始化时创建一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//C为B的实现，B是一个接口</span></span><br><span class="line"><span class="keyword">this</span>.b = <span class="keyword">new</span> C();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">b.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>这段代码看上去没什么问题但是如果你想要替换一个B的实现就不得不修改<code>A</code>类的代码，违反了<code>开闭原则</code>。那么有什么办法解决这个问题呢？在回答这个问题之前，首先来看一下上面这个例子中类A做了哪些事情。第一步它创建了一个<code>B</code>的实现<code>C</code>，然后在<code>foo</code>方法中调用了对象方法<code>method</code>。简言之A类既负责对象的创建也负责对象的使用。这是一个非常不好的现象，因为这样做导致了<code>A</code>类的职责过重。<strong>与一个对象相关的职责通常有三类：对象本身所具有的职责、创建对象的职责和使用对象的职责。对象本身的职责比较容易理解，就是对象自身所具有的一些数据和行为，可通过一些公开的方法来实现它的职责。</strong> 在<code>A</code>类中替换实现实际上是对对象创建过程的修改。让替换不影响<code>A</code>类就需要把<code>A</code>类的对象创建职责分离出去，这样<code>A</code>类只负责对象的使用，符合<code>单一职责原则</code>，有利于功能的复用和系统的维护。如何分离呢？这里就用到了工厂模式，针对上面的例子我们使用简单工厂来分离对象的创建过程。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> B getB(String <span class="class"><span class="keyword">type</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span>(StringUtil.equals(<span class="class"><span class="keyword">type</span>,<span class="title">type1</span>))&#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(StringUtil.equals(<span class="class"><span class="keyword">type</span>,<span class="title">type2</span>)) &#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line"><span class="keyword">public</span> A (String <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">this.b = Factory.getB(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> foo()&#123;</span><br><span class="line">b.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来如果需要替换<code>B</code>的实现，只需要修改工厂类中的静态工厂方法，然后通过不同的参数来切换<code>B</code>的实现。使用工厂模式还有一个好处就是如果在创建对象的过程中还需要执行一些初始化或者参数设置的操作就可以把这些过程集中在工厂中，而不是让它散落在各处，不仅重复而且难以维护。</p><p>在<code>Java</code>中重载的构造函数的使用只能通过参数列表的不同来区分。如果需要使用不同的构造函数来创建对象，工厂模式提供了一个方便，我们可以提供多个名字不同的工厂方法来对应不同的构造函数。这样使用的方便性和代码的可读性会更好。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>在简单工厂又称静态工厂模式中，如果我们需要增加接口的具体实现，不得不修改工厂方法，这显然不符合<code>开闭原则</code>，那么有什么解决方法呢？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单工厂解决了单一类职责过重的问题，将对象的创建过程分离到工厂类中，但是造成了工厂类的复杂性。<br>工厂方法中充斥这大量条件判断和初始化语句。随着具体实现种类的增加，工厂方法势必越来越复杂，变的难以维护。还有一个很重要的问题，如果工厂方法不可用，那么所有涉及的对象使用都将发生错误。这将是一个很大的风险。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何提升你的能力？给年轻程序员的几条建议</title>
      <link href="/2017/07/26/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%9F%E7%BB%99%E5%B9%B4%E8%BD%BB%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%87%A0%E6%9D%A1%E5%BB%BA%E8%AE%AE/"/>
      <url>/2017/07/26/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%9F%E7%BB%99%E5%B9%B4%E8%BD%BB%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%87%A0%E6%9D%A1%E5%BB%BA%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>一转眼工作已有8年，前两天公司一位初入职场的同事希望我给一些建议与经验。我觉得这个话题很有价值，这里以个人的想法与经历写成此文，希望给年轻的开发者们一些启发。<br><a id="more"></a><br>我工作过的公司有4家，<code>NVIDIA</code>, <code>Google</code>, <code>Slide</code>和<code>Glow</code>。其中两家是知名的大公司，<code>Slide</code>我是D轮过后加入的，那时约150人。<code>Glow</code>则是从它第一天创立，一直走到现在。个人的工作也从<code>Developer</code>，<code>Tech Lead</code>，<code>Engineering</code> <code>Manager</code>到<code>CTO</code>。这些经历使我对程序员的个人发展之路有比较全面的看法。</p><p>如果你问一个年轻的前端开发人员，你在今后的3年内如何提升自己的能力？他可能会说“我现在对<code>Web</code>前端比较熟悉，但我想深入了解<code>AngularJS</code>，另外<code>React</code>现在发展的很快我也想看一下。之后，我会花时间去学习<code>iOS</code>和<code>Android</code>开发。”看上去不错，但缺乏系统性的目标。或者说，他制定了学什么，但对为什么要学这些并没有仔细的思考。</p><p>在技术领域，有太多的东西会迅速的过时，如何利用有限时间，最大化你的长期收益？这里我可以给出几条建议</p><h2 id="打造你的工具箱"><a href="#打造你的工具箱" class="headerlink" title="打造你的工具箱"></a>打造你的工具箱</h2><p>工欲善其事，必先利其器。每个开发者都应该有一把自己的瑞士军刀，在将来漫长的职业生涯中，这些工具可以为你省下宝贵的时间，并帮助你更好的组织个人知识库。举两个例子</p><ul><li>一套高效的开发环境</li><li>一个信息采集器和一本笔记本</li></ul><h4 id="高效的开发环境"><a href="#高效的开发环境" class="headerlink" title="高效的开发环境"></a>高效的开发环境</h4><p>我们可以从编缉器谈起，这里有<code>IDE vs Text Editor</code>，有<code>Vim vs Emacs</code>，有<code>Sublime vs Atom</code>，那该如何选择呢？在做选择之前，我们先想想自己的目标。我们希望这是一个长期的投资，这款编缉器能被长期使用，在这个过程不断的打磨，使其能完全适合自己的习惯，最大化编缉效率。如果程序员是侠客，编缉器则是他手中的剑。</p><p>虽然我是<code>Vim</code>的重度用户，但我觉得当年选择<code>Vim</code>时有欠考虑。如果让我重选一次，我的第一选择会是<code>Emacs</code>，第二选择会是<code>Atom</code>。<code>Emacs</code>已存在30年，社区仍然活跃，其可扩展性在编缉器中无人能出其右。<code>Emacs</code>的脚本语言<code>elisp</code>又是<code>lisp</code>的一种<code>dialect</code>，我觉得对<code>lisp</code>的学习可以提升程序员对编程核心思想的理解。另一个加分点是Emacs由于其本身的高门槛及<code>lisp</code>特质，吸引了大批高质素的程序员，其社区可谓藏龙卧虎，更诞生了像<code>Org-mode</code>这样神级的插件。反观<code>Vim</code>，<code>Vim</code>的精髓在于<code>Mode</code> <code>editing</code>，这是值得学习的，可以极大提高文本编缉的效率。但当你熟悉了这一理念后，我觉得可以转投其他编缉器，因为<code>Vim</code>的架构与<code>Vimscript</code>限制了其扩展性。<code>Emacs</code>通过<code>Evil</code>插件非常完整的支持了<code>Mode editing</code>，其他主流的编辑器也有类似插件，所以你一旦掌握了这个理念，在别的编辑器中也可以发挥作用。可能有人会说没有一个<code>Vim emulator</code>能做到<code>Vim 100%</code>的功能，但重点不在于某条指令是否被移植，而是<code>mode editing</code>思想的精髓能否被移植，我觉得答案是肯定的。</p><p>再看<code>Atom vs Sublime</code>，<code>Atom</code>的可扩展性非常好，它的大部分核心功能也是以插件的方式实现，这点与<code>Emacs</code>有异曲同工之妙。并且其开源的特性，使我相信它有比<code>Sublime</code>更持久的生命力。</p><p>关于<code>IDE</code>，我的看法是，我不排斥<code>IDE</code>，但每个<code>IDE</code>都是为了某个特定的任务或是编程语言服务的。做为一个有追求的程序员，可以用<code>IDE</code>，但依然需要精通一个强大的通用编缉器。</p><p>类似编缉器，高效的开发环境还包括<code>Shell</code>，<code>Launcher</code>，窗口管理器，文档阅读器等等。其中有一部分只需要你化很少的时间就可以完成配置，它们的投资回报率是非常高。</p><h4 id="信息采集器和笔记本"><a href="#信息采集器和笔记本" class="headerlink" title="信息采集器和笔记本"></a>信息采集器和笔记本</h4><p>前者是用来收集别人产生的信息，后者则是收集自己产生的信息。前者一个简单的例子就是浏览器的<code>Bookmark</code>。你需要能随时将一组有用的信息归档，并在未来的某个时刻快速找到它。后者最直观的例子则是<code>Mac OS</code>或是<code>iOS</code>自带的笔记本，这里的目的是能随时随地记录你自己的想法。从本质上讲，就是你需要有一套好用的工具来做你的知识库管理<code>（Knowledge management）</code>，也可以说是你知识和思想的外部备份。我个人现在是用<code>Evernote</code>同时来做信息采集与笔记的。如果有一个好的流程，你也完全可以用两个工具来分别把这两件事做好。但我建议你花足够多的时间来思考如何组织你的个人知识库。</p><p>以上只是两个典型的例子，你需要做的是发现那些你要长期从事的任务（往往不随技术而改变，也不随公司而改变），将完成这些任务所需的工具调整至最优。再举一个例子，我会留意身边的程序员所用的键盘。只有少部分的程序员会买高端的静电容键盘，比如<code>HHKB</code>。而在我看来，这明显是一笔很划得来的投资，程序员在工作的大部分时间里都需要和键盘打交道，一个舒适的打字体验是非常有收益的，更何况这类高品质的键盘都非常的耐用。</p><h2 id="开阔你的视野，构建你的技术体系"><a href="#开阔你的视野，构建你的技术体系" class="headerlink" title="开阔你的视野，构建你的技术体系"></a>开阔你的视野，构建你的技术体系</h2><p>首先你要给自己设定一个目标，就如同一个公司会设定它的<code>Vision</code>。</p><ul><li>目标要够大，这样你才能看到更多的风景。</li><li>目标应该设定在解决哪一类问题，而不是精通哪一类技术。技术只是手段，不是目的。</li></ul><p>例如，“我要成为<code>iOS developer</code>中的达人”这个目标，就远不如“我要成为前端应用开发的专家”来得有意义。前者学到深处你可能会去钻研<code>iOS framework</code>里各种奇技淫巧，而后者你会开始关注视觉与交互设计，研究各平台间的差异与共同趋势。显然，后者更有助于你的个人发展。</p><p>不过即便有了明确的目标，选择哪一类技术学习，如何学习，在信息过载的今天依然是一个难题。常有的观点是应该学习最新的技术，因为老的已经过时，而反对的观点则是新技术还不成熟。我个人的观点是，当初入一个领域时，选择主流技术框架；当你有一定经验后，选择技术时更应该关注背后的推动者，我相信优秀的人和团队总能打造优秀的产品，无论是商业公司还是开源社区。不必太在意技术的新旧，因为可能很快都会成为过去时。你真正要学习的是技术背后的思想。有不少语言与开源项目会写它的<code>Coding philosophy</code>，这是很有意思的，你可以从它们的源代码中去验证这些编程理念。以<code>Python</code>为例，如果你执行<code>import this</code>就会看到它的理念，再如Python中一个著名的开源库<code>Celery</code>，在它的文档有专门一节讲述它的<a href="http://celery.readthedocs.org/en/latest/internals/guide.html#philosophy" target="_blank" rel="noopener">编程理念</a>。它们对你的影响会比这些技术本身来得更深远，这是我给初学者们的一个忠告。同理，我非常推荐读一些优秀开源库或是语言的源代码，例如<code>Python</code>的标准库绝大部分都是用<code>Python</code>实现的，而且可读性非常好。如果学习一门技术仅仅停留在用的层面上，你就还没有完全吸取其中的精华，而且学习的收益会随着技术的过时而消失。</p><p>我的另一个学习原则是，在选择学习一门新技术时，最大化它与你现有知识库的差异性。读起来可能有拗口，例如你会<code>Django</code>，接下去你应该去学习<code>Ruby on Rails</code>还是<code>NodeJS</code>? 依据这个原则，你应该学<code>NodeJS</code>，因为它的异步IO模型在理念上与<code>Django</code>的同步模型差异很大，而<code>RoR</code>则与<code>Django</code>更多相似之处。但更好的选择是不要去学另一个<code>Web framework</code>，去学习<code>ZeroMQ</code>或是<code>Redis</code>，这两者对于Web development也非常有帮助，这样就做到了最大化差异。从构建一个程序员的技术理念角度，我会推荐每一个程序至少去了解Lisp或是一门<code>Functional programming language</code>，不管你是否会在可见的未来用到，它们能让你从一个不同的角度看待编程。</p><p>最后我建议每个程序员都应该经营一款自己的产品，它可以是一款<code>app</code>，一个网站或是一个开源软件。除非你是一个创业公司的早期员工，不然你可能没有机会将所有学到的技术或是理念都付之实践，有很多人想成为全栈工程师，最快的捷径就是打造一款自己的产品。任何一个设计师都会精心打造自己的<code>Portfolio</code>，但大部分程序员却不会。当评估一个程序员的<code>Coding</code>能力时，我会去看他的<code>Github</code>上是否有出彩的项目，可惜国内绝大部分程序员的<code>Github</code>空空如也，或者只有一些非常简单的程序。我建议大家好好经营自己<code>Github</code>上项目，这不但可以提高你的声誉，对你将来的求职也非常有帮助。当你报怨求职面试时又被问到各种无厘头的程序题时，有没有想过面试官也很无奈，因为他没有任何其他方法得知你的<code>Coding</code>能力究竟如何。如果每一个程序员都有自己的作品，我想程序员的面试会简单许多。</p><h2 id="重视沟通能力的培养"><a href="#重视沟通能力的培养" class="headerlink" title="重视沟通能力的培养"></a>重视沟通能力的培养</h2><p>当被问到“你觉得<code>Junior Developer</code>和<code>Senior Developer</code>最大的差别是什么”时，我最自然的反应是沟通与文档。沟通包括程序员团队内部的沟通，与其他团队的沟通，与<code>Manager</code>的沟通等等。我不认为自己有能力把这些问题非常概括地说清楚，不过我可以给一条建议，那就是先学会和你的<code>Manager</code>沟通，让他来教你其余的部分。许多公司都会设置<code>Manager</code>与组员的<code>1:1</code>，一个有效率的<code>1:1</code>应该大部分时间有组员来主导。这需要你在<code>1:1</code>之前花足够多的时间来考虑要问的问题，并且最好提前1天发给<code>Manager</code>，让他有机会思考答案。许多人对此不太重视，或者只问非常具体的问题而不是一些开放性问题，这样你很难在你的<code>Manager</code>身上学到东西。如果你渐渐懂得如何利用<code>1:1</code>的时间，它很会成为你在工作中单位时间投资回报率最高的活动。</p><h2 id="累积你的人脉"><a href="#累积你的人脉" class="headerlink" title="累积你的人脉"></a>累积你的人脉</h2><p>每个人都明白人脉的重要性，但实际做起来却不容易。参加一些线下的会议或是活动，可能是最直接的扩展人脉的方式之一。可惜大部分人似乎只是去听了一场技术讲座就回家了。当然，这和不少活动的时间安排也有关系，讲座时间排得太满，茶歇时间短，加上有时嘉宾迟到或是没控制好时间，干脆就把茶歇取消了。而实际上，结识一两个同道中人远比听技术讲座有价值。下次去参加这类会议，不妨给你自己设个目标，比如至少加两个同行的微信。之后维系你的人脉可能需要花更多的时间，下了班或是周末找你的朋友们喝个咖啡吧！</p><p>另外我觉得每个人都需要一个职场导师，他可以是你第一份工作的导师或是<code>Manager</code>，也可以是你认识的其他前辈。你们需要维系一个非常长期的关系，不止于一家公司，最好贯穿你的整个职业生涯。每当你遇到疑惑时，都可以询求他的建议，我觉得这将是你最宝贵的一笔人脉财富。</p><h2 id="寻找发挥你才华的平台"><a href="#寻找发挥你才华的平台" class="headerlink" title="寻找发挥你才华的平台"></a>寻找发挥你才华的平台</h2><p>最后也是最重要的一步，找到适合你的公司。做为求职者评估一家公司可以看三个方面</p><ul><li>公司的发展前景（大公司的话，看所在部门的发展前景）</li><li>你将要加入的团队</li><li>薪资福利</li></ul><p>所以在面试一家公司的时候，你要意识到面试是双向的，公司在面试你的同时，你也在面试这家公司。面试前你应该对这家公司做足功课，准备好一些有质量的问题，比如指出产品中的问题，询问开发流程或是如何做绩效评估。到时你也可以检验一下你的面试官是否合格。</p><p>每次选择公司对以上三个方面都应兼顾，但在职业生涯的不同阶段，侧重点不同。比如，在刚刚工作时，加入一个优秀的团队最为重要，他们可以教会你很多东西，提升你的能力。工作5年之后，你需要一个平台施展你的才华，体现个人价值，公司发展前景的重要性迅速提升。当你做出一番成绩，证明了自己的价值之后，逐渐进入收获期，就有了与公司要价的资格。另一方面，团队实力对公司的前景也有很大的影响。</p><p>对一个刚毕业，初入职场的同学，一个近几年被问了无数次的问题“我的第一份工作是去创业公司还是大公司？”我的回答仍旧是“加入一个优秀的团队最为重要”。一些知名的大公司，团队的素质是有一定保证，但创业公司则不然，团队素质参差不齐，所以如我前面所说你需要面试这个团队，做出自己的判断。不过除了团队因素之外，我想提一下毕业生去创业公司的几个好处。首先，在刚毕业的一段时间内，经济压力小，是最自由最能承受风险的时期，而这段时间往往不长，所以应把握好这个去创业公司的黄金时段。其次，所有的学生进入大公司后，都会担任初级职位，某种程度上来讲是学校学习的延续，规范有条理，但缺乏独立性和创新性，而这正是中国大部分学生所欠缺的。这方面的能力在一家创业公司可以得到快速锻炼，而在大公司可能要等升到中级职位后才有这方面的机会。个人观点，仅供参考。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我觉得步入职场的前3年对今后的发展尤其重要，希望此文能对年轻的程序员们有所帮助。欢迎评论！</p><p><a href="http://tech.glowing.com/cn/author/ryan/" target="_blank" rel="noopener"></a></p><h4 id="叶剑烨"><a href="#叶剑烨" class="headerlink" title="叶剑烨"></a><a href="http://tech.glowing.com/cn/author/ryan/" target="_blank" rel="noopener">叶剑烨</a></h4><p>Head of Technology at Glow</p><p>中国，上海 <a href="http://yejianye.com/" target="_blank" rel="noopener">http://yejianye.com</a></p><h4 id="原文链接-如何提升你的能力？给年轻程序员的几条建议"><a href="#原文链接-如何提升你的能力？给年轻程序员的几条建议" class="headerlink" title="原文链接# 如何提升你的能力？给年轻程序员的几条建议"></a>原文链接<a href="http://tech.glowing.com/cn/advices-to-junior-developers/" target="_blank" rel="noopener"># 如何提升你的能力？给年轻程序员的几条建议</a></h4>]]></content>
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVN服务器搭建实践</title>
      <link href="/2017/07/25/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/07/25/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>本着爱折腾的精神，搭建了<code>svn</code>服务器。<br><a id="more"></a></p><h2 id="什么是svn？"><a href="#什么是svn？" class="headerlink" title="什么是svn？"></a>什么是svn？</h2><blockquote><p>Apache Subversion（简称SVN，svn），一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS转移到Subversion。 —维基百科</p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><blockquote><p><strong><em>aliyun:CentOS Linux release 7.3.1611 (Core)</em></strong></p></blockquote><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><h3 id="安装svn"><a href="#安装svn" class="headerlink" title="安装svn"></a>安装svn</h3><h4 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h4><p><code>yum -y install subversion</code></p><h4 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h4><p><code>svn --version</code></p><h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><p><code>systemctl enable svnserve.service</code> 或 <code>systemctl enable svnserve</code></p><h3 id="配置svn"><a href="#配置svn" class="headerlink" title="配置svn"></a>配置svn</h3><h4 id="配置svn目录"><a href="#配置svn目录" class="headerlink" title="配置svn目录"></a>配置svn目录</h4><p><code>mkdir /home/svn</code>这里我把它放在<code>/home/svn</code>目录下。</p><h4 id="新建版本仓库"><a href="#新建版本仓库" class="headerlink" title="新建版本仓库"></a>新建版本仓库</h4><p><code>svnadmin create /home/svn/project</code></p><h4 id="仓库下文件目录简介"><a href="#仓库下文件目录简介" class="headerlink" title="仓库下文件目录简介"></a>仓库下文件目录简介</h4><blockquote><ul><li><code>conf</code> 存放版本库的配置文件，包括<code>authz</code>,<code>passwd</code>,<code>svnserve.conf</code></li><li><code>db</code> 存放着 <code>Subversion</code> 所要管理的所有受版本控制的数据，不同的存储方式（<code>Berkeley DB</code>或者 <code>FSFS</code>）下有着不同的目录结构，不过我们一般不用直接修改和查看这个目录下的内容，<code>Subversion</code> 的命令可以安全的操作这个目录。</li><li><code>hooks</code> 存放着钩子脚本及其模版（一种版本库事件触发程序）。</li><li><code>locks</code> 存放着 <code>Subversion</code> 版本库锁定数据。</li><li><code>format</code> 记录了版本库的布局版本号。</li><li><code>README.txt</code> 这个就不多说了，自行阅读。</li></ul></blockquote><h4 id="配置用户名密码"><a href="#配置用户名密码" class="headerlink" title="配置用户名密码"></a>配置用户名密码</h4><blockquote><p><code>passwd</code> 用户名和密码</p></blockquote><p>非常简单，使用<code>username</code> = <code>passwd</code>格式就可以了。</p><h4 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h4><blockquote><p><code>authz</code> 资源访问权限</p></blockquote><p>该配置文件由一个<code>[groups]</code>配置段和若干个版本库路径权限段组成。</p><p><code>[groups]</code>配置段中配置行格式如下：</p><p><code>&lt;用户组&gt;</code> = <code>&lt;用户列表&gt;</code></p><p>用户列表由若干个用户组或用户名构成，用户组或用户名之间用逗号<code>&quot;,&quot;</code>分隔，引用用户组时要使用前缀<code>&quot;@&quot;</code>(如：引用用户组<code>&quot;all&quot;</code>要使用字符串<code>&quot;@all&quot;</code>)。</p><p>版本库路径权限段的段名格式如下：</p><p><code>[&lt;版本库名&gt;:&lt;路径&gt;]</code></p><p>如版本库abc路径/tmp的版本库路径权限段的段名为<code>&quot;[abc:/tmp]&quot;</code>。</p><p>可省略段名中的版本库名。若省略版本库名，则该版本库路径权限段对所有版本库中相同路径的访问控制都有效。</p><p>如：段名为<code>&quot;[/tmp]&quot;</code>的版本库路径权限段设置了所有引用该权限配置文件的版本库中目录<code>&quot;/tmp&quot;</code>的访问权限。</p><p>版本库路径权限段中配置行格式有如下三种：</p><p><code>&lt;用户名&gt;</code> = <code>&lt;权限&gt;</code></p><p><code>&lt;用户组&gt;</code> = <code>&lt;权限&gt;</code></p><p><code>&quot;*&quot;</code>= <code>&lt;权限&gt;</code></p><p>其中，<code>&quot;*&quot;</code>表示任何用户；权限的取值范围为<code>&#39;&#39;</code>、<code>&#39;r&#39;</code>和<code>&#39;rw&#39;</code>，<code>&#39;&#39;</code>表示对该版本库路径无任何权限，<code>&#39;r&#39;</code>表示具有只读权限，<code>&#39;rw&#39;</code>表示有读写权限。</p><p><em>注意：每行配置只能配置单个用户或用户组。</em></p><p><em>示例配置:</em></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">g_admin = admin,thinker</span><br><span class="line"><span class="section">[admintools:/]</span></span><br><span class="line">@g_admin = rw</span><br><span class="line">* =</span><br><span class="line"><span class="section">[test:/home/thinker]</span></span><br><span class="line">thinker = rw</span><br><span class="line">* = r</span><br></pre></td></tr></table></figure><p>在上述配置文件中，定义了一个用户组<code>&quot;g_admin&quot;</code>，该用户组包含用户<code>&quot;admin&quot;</code>和<code>&quot;thinker&quot;</code>。然后定义了2个版本库路径权限段。 其中，版本库<code>&quot;admintools&quot;</code>只有用户组<code>&quot;g_admin&quot;</code>可读写，其他用户无任何权限；版本库<code>&quot;test&quot;</code>中路径<code>&quot;/home /thinker&quot;</code>只有用户<code>&quot;thinker&quot;</code>有读写权限，其他用户只有可读权限。</p><h4 id="配置svnserve"><a href="#配置svnserve" class="headerlink" title="配置svnserve"></a>配置svnserve</h4><blockquote><p><code>svnserve.conf</code> 服务器配置</p></blockquote><p><em>主要配置：</em></p><ol><li><p><code>anon-access</code> 控制非鉴权用户访问版本库的权限。取值范围为<code>&quot;write&quot;</code>、<code>&quot;read&quot;</code>和<code>&quot;none&quot;</code>。<br>即<code>&quot;write&quot;</code>为可读可写，<code>&quot;read&quot;</code>为只读，<code>&quot;none&quot;</code>表示无访问权限。<br>缺省值：<code>read</code>，这里设置为<code>none</code></p></li><li><p><code>auth-access</code> 控制鉴权用户访问版本库的权限。取值范围为<code>&quot;write&quot;</code>、<code>&quot;read&quot;</code>和<code>&quot;none&quot;</code>。<br>即<code>&quot;write&quot;</code>为可读可写，<code>&quot;read&quot;</code>为只读，<code>&quot;none&quot;</code>表示无访问权限。<br>缺省值：write 这里设置为<code>write</code></p></li><li><p><code>password-db</code> 指定用户名口令文件名。除非指定绝对路径，否则文件位置为相对<code>conf</code><br>目录的相对路径。<br>缺省值：<code>passwd</code> 这里设置为<code>passwd</code></p></li><li><p><code>authz-db</code> 指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制。<br>除非指定绝对路径，否则文件位置为相对<code>conf</code>目录的相对路径。<br>缺省值：<code>authz</code> 这里设置为<code>authz</code></p></li><li><p><code>realm</code> 指定版本库的认证域，即在登录时提示的认证域名称。若两个版本库的<br>认证域相同，建议使用相同的用户名口令数据文件。<br>缺省值：一个<code>UUID</code>(<code>Universal Unique IDentifier</code>，全局唯一标示)。<br>这里建议设置为版本库名称</p></li></ol><h3 id="启动svn"><a href="#启动svn" class="headerlink" title="启动svn"></a>启动svn</h3><p><code>vi /etc/sysconfig/svnserve</code> 将<code>OPTIONS</code>改为<code>&quot;-r /home/svn&quot;</code>,即<code>svn仓库根目录</code>。</p><p>而后<code>systemctl start svnserve</code>或<code>service svnserve start</code></p><p>使用<code>systemctl status svnserve.service</code>查看服务启动状态。</p><p>使用<code>service svnserve stop</code>停止服务或者使用<code>ps aux|grep svnserve</code>后，<code>kill</code>掉进程。</p><p>使用 <code>service svnserve restart</code>重启服务。</p><h3 id="使用客户端连接"><a href="#使用客户端连接" class="headerlink" title="使用客户端连接"></a>使用客户端连接</h3><ul><li><code>windows</code>下载<a href="https://tortoisesvn.net/downloads.zh.html" target="_blank" rel="noopener"><code>TortoiseSVN</code></a></li><li><code>mac os</code> 下载<a href="http://www.sdifen.com/cornerstone303.html" target="_blank" rel="noopener"><code>Cornstone</code></a></li></ul><pre><code>**然后`svn checkout`**</code></pre><h2 id="svn的存储特性简介"><a href="#svn的存储特性简介" class="headerlink" title="svn的存储特性简介"></a>svn的存储特性简介</h2><table><thead><tr><th>特性</th><th>Berkeley DB</th><th>FSFS</th></tr></thead><tbody><tr><td>对操作中断的敏感</td><td>很敏感；系统崩溃或者权限问题会导致数据库“塞住”，需要定期进行恢复。</td><td>不敏感</td></tr><tr><td>可只读加载</td><td>不能</td><td>可以</td></tr><tr><td>存储平台无关</td><td>不能</td><td>可以</td></tr><tr><td>可从网络文件系统访问</td><td>不能</td><td>可以</td></tr><tr><td>版本库大小</td><td>稍大</td><td>稍小</td></tr><tr><td>扩展性：修订版本树数量</td><td>无限制</td><td>某些本地文件系统在处理单一目录包含上千个条目时会出现问题。</td></tr><tr><td>扩展性：文件较多的目录</td><td>较慢</td><td>较慢</td></tr><tr><td>检出最新代码的速度</td><td>较快</td><td>可以</td></tr><tr><td>大量提交的速度</td><td>较慢，但时间被分配在整个提交操作中</td><td>较快，但最后较长的延时可能会导致客户端操作超时</td></tr><tr><td>组访问权处理</td><td>对于用户的 umask 设置十分敏感，最好只由一个用户访问。</td><td>对 umask 设置不敏感</td></tr><tr><td>功能成熟时间</td><td>2001 年</td><td>2004 年</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>svn管理员可以通过这3个配置文件设置svnserve服务的用户名口令，以及对版本库路径的访问权限。这些配置文件保存后就立即生效，不需要重启svnserve服务。</p>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>yum命令的简单使用</title>
      <link href="/2017/07/22/yum%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/07/22/yum%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>平时维护着一台个人阿里云服务器，上面跑着blog和一些小玩意。管理程序经常使用yum命令，所以总结下它的一些常用的用法。<br><a id="more"></a></p><h2 id="什么是yum？"><a href="#什么是yum？" class="headerlink" title="什么是yum？"></a>什么是yum？</h2><p>yum（Yellow dog Updater, Modified）命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><p>yum (选项)(参数)</p></blockquote><hr><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><blockquote><ul><li>-h：显示帮助信息；</li><li>-y：对所有的提问都回答“yes”；</li><li>-c：指定配置文件；</li><li>-q：安静模式；</li><li>-v：详细模式；</li><li>-d：设置调试等级（0-10）；</li><li>-e：设置错误等级（0-10）；</li><li>-R：设置yum处理一个命令的最大等待时间；</li><li>-C：完全从缓存中运行，而不去下载或者更新任何头文件。 参数</li></ul></blockquote><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><ul><li>install：安装rpm软件包；</li><li>update：更新rpm软件包；</li><li>check-update：检查是否有可用的更新rpm软件包；</li><li>remove：删除指定的rpm软件包；</li><li>list：显示软件包的信息；</li><li>search：检查软件包的信息；</li><li>info：显示指定的rpm软件包的描述信息和概要信息；</li><li>clean：清理yum过期的缓存；</li><li>shell：进入yum的shell提示符；</li><li>resolvedep：显示rpm软件包的依赖关系；</li><li>localinstall：安装本地的rpm软件包；</li><li>localupdate：显示本地rpm软件包进行更新；</li><li>deplist：显示rpm软件包的所有依赖关系。</li></ul></blockquote><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><ul><li>yum install #全部安装</li><li>yum install package1 #安装指定的安装包package1</li><li>yum groupinsall group1 #安装程序组group1</li></ul></blockquote><hr><h3 id="更新和升级"><a href="#更新和升级" class="headerlink" title="更新和升级"></a>更新和升级</h3><blockquote><ul><li>yum update #全部更新</li><li>yum update package1 #更新指定程序包package1</li><li>yum check-update #检查可更新的程序</li><li>yum upgrade package1 #升级指定程序包package1</li><li>yum groupupdate group1 #升级程序组group1</li></ul></blockquote><hr><h3 id="查找和显示"><a href="#查找和显示" class="headerlink" title="查找和显示"></a>查找和显示</h3><blockquote><ul><li>yum info package1 #显示安装包信息package1</li><li>yum list #显示所有已经安装和可以安装的程序包</li><li>yum list package1 #显示指定程序包安装情况package1</li><li>yum groupinfo group1 #显示程序组group1信息</li><li>yum search string 根据关键字string查找安装包</li></ul></blockquote><hr><h3 id="删除程序"><a href="#删除程序" class="headerlink" title="删除程序"></a>删除程序</h3><blockquote><ul><li>yum remove | erase package1 #删除程序包package1</li><li>yum groupremove group1 #删除程序组group1</li><li>yum deplist package1 #查看程序package1依赖情况</li></ul></blockquote><hr><h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><blockquote><ul><li>yum clean packages #清除缓存目录下的软件包</li><li>yum clean headers #清除缓存目录下的 headers</li><li>yum clean oldheaders #清除缓存目录下旧的 headers</li></ul></blockquote><hr><h4 id="参考：http-man-linuxde-net"><a href="#参考：http-man-linuxde-net" class="headerlink" title="参考：http://man.linuxde.net/"></a>参考：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></h4>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java静态导入</title>
      <link href="/2017/07/22/%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E6%B5%85%E6%9E%90/"/>
      <url>/2017/07/22/%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><code>JDK1.5</code>引入了<code>static import</code>机制,借助这一机制，可以用略掉所在的类或接口名的方式来使用静态成员。为什么要这么做呢？因为我们知道在Java中常量和函数是不能单独存在的，必须要依附于类或者接口。在这种情况下我们访问常量和函数时必须带上类或者接口名来做限定。静态导入或者叫静态成员导入就是为了解决这一问题，让我们可以像访问本类中的变量和函数一样访问外部变量和函数。</p><hr><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="精确导入"><a href="#精确导入" class="headerlink" title="精确导入"></a>精确导入</h3><p> 精确的导入一个静态成员的方法，是在源文件的开头部分（任何类或接口的定义之前），加上类似这样的声明：<br><code>import static 包名.类或接口名.静态成员名;</code></p><p>==注意尽管这个机制的名称叫做<code>“static import”</code>，但是在这里的次序却是正好相反的<code>“import static”</code>。==</p><pre><code>//精确的导入Math.sin和Math.PIimport static java.lang.Math.sin;import static java.lang.Math.PI;public class staticImportSampleA {    public static void main(String[] args) {           System.out.println(sin(PI/2));//输出“1.0”  } }</code></pre><h3 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h3><p><code>static import</code>机制也支持一种不必逐一指出静态成员名称的导入方式。这时，要采用这样的语法：<br><code>import static 包名.类或接口名.*;</code><br>==注意这种方式只是指出遇到来历不明的成员时，可以到这个类或接口里来查找，并不是把这个类或接口里的所有静态成员全部导入。==</p><pre><code>//声明遇到来历不明的成员时到java.lang.Math中去寻找import static java.lang.Math.*;public class staticImportSampleB {    public static void main(String[] args) {        System.out.println(sin(PI/2));//输出“1.0”    }}</code></pre><hr><h3 id="可以导入一切静态成员"><a href="#可以导入一切静态成员" class="headerlink" title="可以导入一切静态成员"></a>可以导入一切静态成员</h3><p>使用<code>import static</code>语句，可以导入一个类里的一切被static修饰的东西，包括变量、常量、方法和内部类。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.example.p3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">staticImportee</span> &#123;</span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> TWO = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">three</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Four</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.example.p3;</span><br><span class="line">import <span class="keyword">static</span> com.example.p3.staticImportee.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">staticImporter</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(one);</span><br><span class="line">        System.<span class="keyword">out</span>.println(TWO);</span><br><span class="line">        System.<span class="keyword">out</span>.println(three());</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">new</span> Four());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不受影响的访问控制"><a href="#不受影响的访问控制" class="headerlink" title="不受影响的访问控制"></a>不受影响的访问控制</h3><p><code>static import</code>不能突破<code>Java</code>语言中原有的访问控制机制的限制，不过也并不在这方面增加新的约束。原来有权限访问的静态成员，都可以被导入和使用；而原来无权限访问的静态成员，用了这个方法之后也仍然是不能访问。</p><h2 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h2><h3 id="外部导入冲突"><a href="#外部导入冲突" class="headerlink" title="外部导入冲突"></a>外部导入冲突</h3><p>不同的类（接口）可以包括名称相同的静态成员。因此，在进行<code>static import</code>的时候，可能会出现<code>“两个语句导入同名的静态成员”</code>的情况。<br>在这种时候，JDK1.5会这样来加以处理：</p><ul><li>如果两个语句都是精确导入的形式，或者都是按需导入的形式，那么会造成编译错误。</li><li>如果一个语句采用精确导入的形式，一个采用按需导入的形式，那么采用精确导入的形式的一个有效。</li></ul><p>==注意，如果两个同名的静态成员一个是属性，而另一个是方法，那么因为使用时的写法有差异，不会造成冲突。==</p><h3 id="本地和导入冲突"><a href="#本地和导入冲突" class="headerlink" title="本地和导入冲突"></a>本地和导入冲突</h3><p>有时候，导入的东西还可能和本地的东西相冲突，这种情况下的处理规则是“本地优先”。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在编译期间，所有因<code>static import</code>的存在而简化了的名字，都会被编译器打回原型。因此在性能方面，<code>static import</code>没有任何影响。但是名字简化却可能造成一些维护方面的问题。<br>去掉静态成员前面的类型名，固然有助于在频繁调用时显得简洁，但是同时也失去了关于“这个东西在哪里定义”的提示信息，增加了阅读理解的麻烦。如果导入的来源很著名（比如<code>java.lang.Math</code>），或者来源的总数比较少，这个问题并不严重；但是在不属于这两种的情况下，这就不是基本可以忽略的问题了。</p><p>借助<code>JDK 1.5</code>里提供的<code>static import</code>机制，可以用一种更简单的方式，来访问类和接口的静态成员。不过，使用这一机制并不是没有代价的，在使用不当的时候可能给维护工作带来一定的困扰。因此，在具体使用之前，还要作一些权衡。</p><blockquote><p>ps:普遍做法还是直接通过类名或接口名访问，这样可读性更好。<br>在实际项目中没有遇到过使用这一特性，在这里仅作为一个知识点总结下。</p></blockquote><blockquote><p>参考 <a href="http://blog.csdn.net/xyz_fly/article/details/8178104" target="_blank" rel="noopener">理解Java的static import静态引入机制</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实习体会</title>
      <link href="/2017/04/30/%E5%AE%9E%E4%B9%A0%E4%BD%93%E4%BC%9A/"/>
      <url>/2017/04/30/%E5%AE%9E%E4%B9%A0%E4%BD%93%E4%BC%9A/</url>
      <content type="html"><![CDATA[<p>记得之前问过同是程序员的表哥，“马上要去实习了，我该怎么做？”他只回了一句：“实习就是工作”。<br><a id="more"></a><br>这也是我这段时间最大的感受。实习就是工作，只不过是从学生到正式员工的过度。DM 除了安排我做一些简单的工作外，并没去过多的关注我在干什么。但是从这些安排也能看出他的用心。先是叫我学习老项目的代码，熟悉新框架，改造老项目。然后让我开发新的项目里的一些小功能。在这个过程中，渐渐的熟悉了一部分的业务和框架的使用。同时我也在思考公司业务是否有前途，简单来说就是公司是否值得我待下去。</p><p>公司是和金融机构，银行合作拓展金融业务，分为互联网金融，农村金融，面向不同的群体。事实上仅仅是做一个渠道的作用，自己并没有资金。一个很简单的事实是贷款业务是需要征信的，虽然公司大数据平台花了大量人力物力完成了初期的建设，但是并没有可靠的数据源。没办法完成使用公司内部系统进行征信。所以到现在为止还是调用的第三方的征信系统。而且大数据这个东西，我觉得小公司是很难做起来的。所以根据这些判断我对公司发展前景不是很看好。还是趁着没毕业多去尝试下其他行业，正好机会来了，有个同学公司的内推，简历已经写好了，试试吧 ~</p><p>接下来专心搞毕设，深入学习在公司用到的技术，努力提升自己。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
