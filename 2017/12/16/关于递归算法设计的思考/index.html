<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>关于递归算法设计的思考 | HsiaChyiKwok'Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于递归算法设计的思考</h1><a id="logo" href="/.">HsiaChyiKwok'Blog</a><p class="description">逝者如斯夫，不舍昼夜</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-book"> 时间轴</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于递归算法设计的思考</h1><div class="post-meta">Dec 16, 2017<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2017/12/16/关于递归算法设计的思考/" href="/2017/12/16/关于递归算法设计的思考/#disqus_thread"></a><div class="post-content"><p>之前公司管理系统项目需要配合前端<code>VUE</code>实现动态路由，返回的数据结构是一个树形结构，但在数据库中存储的是平行的数据项。这个时候就需要在代码中去进行数据结构的组装。好久没思考这些问题，花了好些时间才搞定。这其中涉及到递归算法的实现，乘着周末深入的思考了下递归算法的设计，一点点拙见写下来做个笔记。</p>
<h3 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h3><p>对于<code>递归</code>其实我们并不陌生。还记得中学时代经常使用的<code>数学归纳法</code>？，<code>递归</code>其实并不是计算机科学独有的概念。实际上<code>数学归纳法</code>才是递归的理论基础。</p>
<p>先举个简单的栗子：求n! 这里使用递归来求解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n*foo(n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ospalociz.bkt.clouddn.com/66494249ea104641afe09888c25d15bc.svg" alt="栈.svg"></p>
<p>上面代码所表达的含义是：当<code>n</code>不等于<code>1</code>的时候。一直去调用<code>foo（n-1）</code>并且和传入的<code>n</code>相乘。在这里解释下递归调用的实现原理：我们知道计算机中函数的调用是使用栈的数据结构实现的，比如传入的<code>n</code>为<code>5</code>时，第一次执行<code>foo</code>方法，当执行到 <code>foo(n-1)</code>,方法<code>foo</code>会被压入栈中。其实递归方法的出栈入栈和普通方法是一样的。唯一的区别是递归调用的是自身的代码。这里不妨把<code>foo</code>的每次调用称作<code>foo1</code>,<code>foo2</code>等等。那么这样就好理解了，当<code>foo</code>方法执行到<code>n==1</code>的时候，栈里面依次存放着<code>foo1,foo2,foo3,foo4,foo5。</code>此时<code>foo5</code>在栈顶,出栈执行。<code>foo5</code>执行的时候<code>n==1</code>，由代码可知，<code>n==1</code>，方法直接返回<code>1</code>。接着<code>foo4</code>出栈，传入的<code>n</code>为<code>2</code>，运算<code>2*1</code>，然后<code>foo3,foo2,foo1</code>依次出栈，运算依次为：<code>3*2,4*6</code> 当最后一个方法<code>foo1 return</code>时计算，<code>5*24</code>，运行结束。</p>
<p>从这个过程中不难看出，递归是个不断下降的过程。层层调用自身，然后求值又是个上升的过程。从递归结束的出口返回值开始，层层向上求值。</p>
<p>从这个例子中还可以看出递归算法的两个重要特征，比如：</p>
<ol>
<li>不停调用自身</li>
<li>有终止的条件，不然就成了死循环了</li>
</ol>
<p>需要思考的问题是终止条件是如何确定的，以及他是怎么变化的。在上面的程序中是做<code>-1</code>操作。</p>
<h3 id="何时考虑使用递归呢？"><a href="#何时考虑使用递归呢？" class="headerlink" title="何时考虑使用递归呢？"></a>何时考虑使用递归呢？</h3><h4 id="当定义是递归时"><a href="#当定义是递归时" class="headerlink" title="当定义是递归时"></a>当定义是递归时</h4><p>和上面求阶乘的例子类型一样。<code>斐波那契数列</code>的定义就是递归的。直接看代码：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Fib(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">	<span class="built_in">if</span>(<span class="built_in">n</span>==<span class="number">1</span> || <span class="built_in">n</span>==<span class="number">2</span>) &#123;</span><br><span class="line">		return <span class="number">1</span>;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		Fib(<span class="built_in">n</span>-<span class="number">1</span>)+Fib(<span class="built_in">n</span>-<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>斐波那契数列</code> ： <strong>1,1,2,3,5 …</strong></p>
<h4 id="当数据结构本身是递归时"><a href="#当数据结构本身是递归时" class="headerlink" title="当数据结构本身是递归时"></a>当数据结构本身是递归时</h4><p>最常见的比如链表的定义（这里讨论的是没有头节点的链表）：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">	private</span> <span class="keyword">String</span> data; //节点数据域</span><br><span class="line">	private <span class="keyword">Node</span> <span class="title">next</span>; //指向下一个节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要对链表数据域求和时,可以使用递归实现：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SUM(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>) &#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		return <span class="keyword">node</span>.<span class="title">getData</span>()+SUM(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当问题需要用递归求解"><a href="#当问题需要用递归求解" class="headerlink" title="当问题需要用递归求解"></a>当问题需要用递归求解</h4><p><strong>这里详细讨论下汉诺塔算法的实现。</strong></p>
<blockquote>
<p>汉诺塔问题描述：有三个分别叫做X，Y，Z的塔座。在塔座X上有直径各不同，从小到大依次标号为：1，2，3…n的盘片，现在要求把塔座X上的盘片移动到塔座Z上，按相同顺序叠放。移动时需要遵守规则：1.每次只能移动一个盘片。 2.盘片可以放在任意一个塔座上。 3.不能将较大的盘片放在较小的上面。</p>
</blockquote>
<p>汉诺塔是典型的递归求解问题。光看描述不容易分析问题如何分解，不如在问题规模较小时，试着分析下解决方案。</p>
<p><strong>当X塔座上只有一个盘片时：</strong></p>
<p><img src="http://ospalociz.bkt.clouddn.com/a5363090f26846e4a4230eba51011348.png?imageView2/3/h/150" alt="2017-12-16 18.59.15.png"></p>
<p><code>X==&gt;Z</code></p>
<p><strong>当X塔座上有两个盘片时：</strong></p>
<p><img src="http://ospalociz.bkt.clouddn.com/eebe3ae6e806450d9783488842c3903f.png?imageView2/3/h/150" alt="2017-12-16 19.06.34.png"></p>
<p><code>X1==&gt;Y,X2==&gt;Z</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/e5f9650ee7084137b7e2cb0b69a7d171.png?imageView2/3/h/150" alt="2017-12-16 19.07.10.png"></p>
<p><code>Y1==&gt;Z</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/1efe61da98564f5fb183a191092d2343.png?imageView2/3/h/150" alt="2017-12-16 19.07.28.png"></p>
<p><strong>当X塔座上有三个盘片时：</strong></p>
<p><img src="http://ospalociz.bkt.clouddn.com/f679a158056f4c1bb4be44ee7012e776.png?imageView2/3/h/150" alt="2017-12-16 19.14.59.png"></p>
<p><code>X1==&gt;Z,X2==&gt;Y</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/d4d532f41c7e461f9908fb99e37f1ec0.png?imageView2/3/h/150" alt="2017-12-16 19.16.36.png"></p>
<p><code>Z==&gt;Y,X==&gt;Z</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/624a4d7cf1cf4fc3889ab00a5d088a6d.png?imageView2/3/h/150" alt="2017-12-16 19.17.01.png"></p>
<p><code>Y1==&gt;X,Y2==&gt;Z</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/1c52059f2f264dd9876511ed0413e9cb.png?imageView2/3/h/150" alt="2017-12-16 19.17.33.png"></p>
<p><code>X==&gt;Z</code></p>
<p><img src="http://ospalociz.bkt.clouddn.com/a7433272c6b441f7abb8cbff2c3fcc7f.png?imageView2/3/h/150" alt="2017-12-16 19.17.55.png"></p>
<p>先给出递归算法，这个算法将打印出移动的步骤。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hanoi(<span class="keyword">int</span> n,<span class="keyword">String</span> X,<span class="keyword">String</span> Y,<span class="keyword">String</span> Z) &#123;</span><br><span class="line">	<span class="built_in">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="string">"将第"</span>+n+<span class="string">"个盘片从"</span>+X+<span class="string">"移到"</span>+Z); <span class="comment">//X==&gt;Z</span></span><br><span class="line">	&#125;<span class="built_in">else</span> &#123;</span><br><span class="line">	Hanoi(n<span class="number">-1</span>,X,Z,Y);</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="string">"将第"</span>+n+<span class="string">"个盘片从"</span>+X+<span class="string">"移到"</span>+Z); <span class="comment">//X==&gt;Z</span></span><br><span class="line">	Hanoi(n<span class="number">-1</span>,Y,X,Z);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汉诺塔的基本要求是要把最大的放在最下面,所以当<code>X</code>塔座上的盘片数量大于1时，我们首先要把<code>X</code>塔座上，<code>1至n-1</code>的盘片放到<code>Y</code>上，于是我们可以忽略<code>X</code>最下面的盘片，把<code>Y</code>当做<code>Z</code>，<code>Z</code>当做<code>Y</code>，这样问题回到了，当<code>X</code>有<code>n-1</code>个盘片，如何移动到<code>Z</code>的情形。记住这个时候的<code>Z</code>是<code>Y</code>。 现在我们已经做到了把<code>X</code>上<code>1至n-1</code>的盘片放到了<code>Y</code>上。别忘了<code>X</code>上还有一个我们忽略的最大盘片。</p>
<p>好，现在把<code>X</code>最大盘片放到<code>Z</code>，这个时候<code>X</code>没有盘片，<code>Y</code>有<code>1至n-1</code>的盘片，现在我们忽略<code>Z</code>上的最大盘片。将<code>Y</code>当做<code>X</code>，<code>X</code>当做<code>Y</code>。问题又回到了<code>X</code>上有<code>n-1</code>个盘片如何移动到<code>Z</code>的情形。</p>
<blockquote>
<p>再看上面给出的代码。当<code>n==1</code>时，直接把<code>X</code>移到<code>Z</code>，否则，将<code>Y</code>当做<code>Z</code>，<code>Z</code>当做<code>Y</code>，将<code>1至n-1</code>盘片移到<code>Y</code>上。这个时候取出<code>X</code>最大盘片放到<code>Z</code>。再把<code>X</code>当<code>Y</code>，<code>Y</code>当做<code>X</code>，继续递归。直到<code>n==1</code>，移动成功！其实不难发现当执行到第二个<code>System.out.println(&quot;将第&quot;+n+&quot;个盘片从&quot;+X+&quot;移到&quot;+Z);</code>时。已经完成了将<code>X</code>的最大盘片移到<code>Z</code>的目标。汉诺塔的层数减一。问题回到了最初的情形，只不过，盘片在<code>Y</code>上，不在<code>X</code>上。但是这不妨碍调用<code>Hanoi</code>方法。实际上问题的关键在于，<code>X，Y，Z</code>三个塔座没有区别是一样的。还有一轮操作完之后，只是把最下面的盘片放到了<code>Z</code>，这个时候问题的规模就减一了。</p>
</blockquote>
<h3 id="如何设计递归算法？"><a href="#如何设计递归算法？" class="headerlink" title="如何设计递归算法？"></a>如何设计递归算法？</h3><h4 id="找出递归结束条件"><a href="#找出递归结束条件" class="headerlink" title="找出递归结束条件"></a>找出递归结束条件</h4><p>上文总结的递归特征中，有一条说明了递归必须要有终止条件。比如求阶乘，斐波那契数列以及汉诺塔问题，它们在递归调用时表示问题规模的<code>n</code>一直在递减，直到达到递归结束条件<code>n==1</code>。实际上，递归条件不一定是这种通过递减来达到结束条件判断值的，比如在构造树形结构的时候，可以通过判断数据项的<code>isLeaf</code>字段是否为<code>true</code>来决定是否退出递归。有一点可以肯定的是，递归退出条件一定隐藏在初次调用传入方法的参数中以及一切在方法运行时可以访问的状态。</p>
<h4 id="找出循环体"><a href="#找出循环体" class="headerlink" title="找出循环体"></a>找出循环体</h4><p>这是一个比较难的问题，对于类似数学定义问题，循环体往往就是定义问题的那几句话，比如斐波那契数列的定义：<code>当0&lt;n&lt;3时，Fib=1，当n&gt;2时，Fib(n)=Fib(n-1)+Fib(n-2)</code>。当为递归数据结构设计算法时，循环体则是访问递归结构的指令。比如遍历链表时：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">	if</span>(<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</span><br><span class="line">		foo(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是像汉诺塔这类问题，直观上没办法直接看出递归的特征。个人经验则是在较小问题规模上，进行演算。发现递归特征。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>递归程序设计本身是比较难以理解和掌握的，通过简单的理论学习无法熟练运用，只有不断的解决问题才会熟能生巧。</p>
</div><div class="tags"><a href="/tags/递归/">递归</a></div><div class="post-nav"><a class="pre" href="/2018/01/07/装饰模式/">装饰模式</a><a class="next" href="/2017/11/13/深入理解进程及线程/">深入理解进程和线程</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'hsiachyikwok';
var disqus_identifier = '2017/12/16/关于递归算法设计的思考/';
var disqus_title = '关于递归算法设计的思考';
var disqus_url = 'http://www.xiaqiguo.com/2017/12/16/关于递归算法设计的思考/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//hsiachyikwok.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.xiaqiguo.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/递归/" style="font-size: 15px;">递归</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/工厂/" style="font-size: 15px;">工厂</a> <a href="/tags/装饰/" style="font-size: 15px;">装饰</a> <a href="/tags/进程/" style="font-size: 15px;">进程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/装饰模式/">装饰模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/关于递归算法设计的思考/">关于递归算法设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/深入理解进程及线程/">深入理解进程和线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/Java的异常处理机制-续、/">Java的异常处理机制-续、</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/Java的异常处理机制/">Java的异常处理机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/工厂模式之抽象工厂/">工厂模式之抽象工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/工厂模式之工厂方法/">工厂模式之工厂方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/29/工厂模式之简单工厂/">工厂模式之简单工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/如何提升你的能力？给年轻程序员的几条建议/">如何提升你的能力？给年轻程序员的几条建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/22/SVN服务器搭建实践/">SVN服务器搭建实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.taoshengxu.com/" title="陶胜旭的博客" target="_blank">陶胜旭的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">HsiaChyiKwok'Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>