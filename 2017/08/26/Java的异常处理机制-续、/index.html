<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>Java的异常处理机制-续、 | 春华秋实</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java的异常处理机制-续、</h1><a id="logo" href="/.">春华秋实</a><p class="description">逝者如斯夫，不舍昼夜。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-book"> 时间轴</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java的异常处理机制-续、</h1><div class="post-meta">Aug 26, 2017<span> | </span><span class="category"><a href="/categories/Java基础/">Java基础</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2017/08/26/Java的异常处理机制-续、/" href="/2017/08/26/Java的异常处理机制-续、/#disqus_thread"></a><div class="post-content"><p>在<a href="http://www.xiaqiguo.com/articles/2017/08/20/1503226655149.html" target="_blank" rel="noopener">上一篇</a>中简单介绍了异常的概念和基本的使用方法。本篇将继续深入了解异常的使用原则。<br><a id="more"></a></p>
<h4 id="使用finally"><a href="#使用finally" class="headerlink" title="使用finally"></a>使用finally</h4><p>在使用<code>finally</code>时有一些陷阱是需要注意的。我们知道无论是否发生异常<code>finally</code>代码块始终都会被执行。考虑一种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能产生异常的代码块</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line"><span class="comment">//捕获异常后的动作</span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//无论是否捕获异常这里都会执行，通常做一些清理资源的操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果同时在<code>try</code>块和<code>finally</code>块中存在<code>return</code>语句究竟谁会被返回呢？直觉告诉我们好像<code>try</code>中的<code>return</code>执行后方法就结束了吧，应该返回<code>try</code>中的。但是实际上并不是这样，根据<code>finally</code>的用法，最终<code>finally</code>中的返回值将会覆盖<code>try</code>中的返回值（实际验证确实如此）。</p>
<p>根据上面的经验考虑这种情况：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>异常信息在没有得到处理的情况下丢失了。</code></p>
<h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为<code>异常链</code>。</p>
<p><strong>重新抛出异常</strong></p>
<p>有的时候我们希望重新抛出异常:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> e)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">throw</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想将异常抛出点更新为当前方法，可以调用异常的<code>fillInStackTrace()</code>方法，像这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> e)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">throw</span> (<span class="keyword">Exception</span>)e.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者抛出新的异常</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//抛出新的异常</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyException</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的异常信息丢失了。如果想把之前的异常信息保存下来（保存到新的异常对象中），所有的<code>Throwable</code>的子类在构造器中都可以接受一个<code>cause</code>对象作为参数(<code>cause</code>是<code>Throwable</code>类型的)，这个<code>cause</code>就是用来表示原始异常，这样通过把原始异常传递给新的异常，使得我们可以追踪到异常最初发生的地方。</p>
<p>但是在<code>Throwable</code>子类中只有三种基本异常提供了带<code>cause</code>参数的构造器。<code>Error</code>（<code>JVM</code>报告系统错误），<code>Exception</code>，<code>RuntimeException</code>。如果要把其他异常链接起来需要使用<code>initCause()</code>方法而不是构造器。下面是一个示例：</p>
<p><strong>使用构造器：</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyException</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span> (MyException e)&#123;</span><br><span class="line">	RuntimeException e1 = <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">	<span class="keyword">throw</span> e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用<code>initCause()</code>方法</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">	<span class="comment">//抛出新的异常保存原来的异常信息</span></span><br><span class="line">	MyException myException = <span class="keyword">new</span> <span class="type">MyException</span>();</span><br><span class="line">	保存原来的异常信息</span><br><span class="line">   myException.initCause(e);</span><br><span class="line">   <span class="keyword">throw</span> myException; <span class="comment">//这个异常捕获或者抛出它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h4><blockquote>
<p><code>throws</code>关键字</p>
</blockquote>
<p>异常声明在不希望本层处理异常的时候把异常信息向上抛出，由上层代码处理（层层抛出则最终会抛到<code>JVM</code>）。我们在设计抽象层或者类库的时候常常可以在方法后抛出需要处理的异常。这也是使用者需要遵守的约定之一。</p>
<p><code>异常声明本身不属于方法说明的一部分，方法类型是由方法的名字和参数类型组成的（实际上返回值类型也属于方法的组成，所谓方法签名，但是重载只根据方法名和参数列表）。所以不能基于异常声明来重载方法。</code></p>
<p><strong>在继承体系中使用异常应该注意什么？</strong></p>
<p>当覆盖方法或实现接口时只能抛出在基类方法（接口方法）的异常声明中列出的异常。为什么这样呢？我们要理解在方法声明中的异常信息是使用者（子类，实现类）需要遵守的约定之一，你必须处理（抛出）这些没有被处理的异常。所以在继承体系中，异常通常是越抛越少的（因为每层几乎都会处理掉一些）。与之形成对比的是：继承体系中类的方法和数据域往往是越来越丰富的。还有一点:这保证了子类的可替换性，是面向对象的特性。（如果没有这个限制，当替换子类或实现类时，代码将变的不可用，因为异常是不确定的）</p>
<p><strong>构造器中抛出的异常</strong></p>
<p>在继承体系中，派生类的构造器可以抛出任何异常而不受基类构造器异常的限制，但是必须包括基类抛出的异常。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	public <span class="type">A</span>()<span class="keyword">throws</span> <span class="type">MyException1</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	public <span class="type">B</span>() <span class="keyword">throws</span> <span class="type">MyException1</span>,<span class="type">MyException2</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类构造器不能捕获基类构造器抛出的异常。(捕获异常需要用<code>try</code> <code>catch</code> 语句包含，但是调用父类构造器的语句必须要在第一行，显然原则相互违背，编译不会通过)我们知道当类的对象被创建时会依次调用其所有基类的构造器。显然在派生类中捕获基类异常是没有意义的，因为对象创建已经在某个基类中失败了，每个构造器应该只关注自己的行为，如果子类构造器干涉了父类构造器抛出异常信息，那么就不能准确判断创建过程中发生的事了。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>不应该在异常没有处理的情况下再抛出新的异常，这样原来的异常信息就会丢失。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> MyException<span class="number">1</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在异常发生时是不是所有的东西都可以被正确清理？像打开一个文件，获取一个数据库连接这样的操作，需要保证资源最终被释放。但是如果一开始就获取失败呢？考虑下面的这种情况：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>in</code>没有被创建，关闭操作将会失败。改变一下，需要一点点技巧</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	InputFile <span class="keyword">in</span> = <span class="keyword">new</span> InputFile(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">in</span>.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace(System.<span class="keyword">out</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>in</code>没有被正确创建，则会进入外层的<code>catch</code>，嵌套逻辑保证了当内层发生异常时，<code>in</code>一定被创建了。</p>
<h4 id="关于未检查异常"><a href="#关于未检查异常" class="headerlink" title="关于未检查异常"></a>关于未检查异常</h4><p>未检查异常（<code>RuntimeException</code>）是不受检查的异常，意思是编译器不会对它进行警告，它属于<code>运行时异常</code>。这种异常实际上是一种错误（这里说的错误指的是应用运行层面的编程错误），比如<code>NullPointerException</code>空指针异常，它是继承自<code>RuntimeException</code>，想象一下程序在运行过程中某个变量极有可能为空（原因可能是传入参数为空），而导致调用失败，这个时候就需要抛出异常来报告错误。但是在代码编写和编译阶段无法确定异常是否会发生，那么我们就要在每个可能的地方加上异常处理代码，这是相当可怕的。幸运的是<code>JVM</code>为我们处理了这类<code>运行时异常</code>，使我们不必操心运行时的事情。当然你也可以主动抛出<code>RuntimeException</code>或者捕获它。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/2017/11/28/深入理解进程及线程/">深入理解进程和线程</a><a class="next" href="/2017/08/20/Java的异常处理机制/">Java的异常处理机制</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'hsiachyikwok';
var disqus_identifier = '2017/08/26/Java的异常处理机制-续、/';
var disqus_title = 'Java的异常处理机制-续、';
var disqus_url = 'http://blog.xiaqiguo.com/2017/08/26/Java的异常处理机制-续、/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//hsiachyikwok.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mind/">mind</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/mind/" style="font-size: 15px;">mind</a> <a href="/tags/工厂/" style="font-size: 15px;">工厂</a> <a href="/tags/装饰/" style="font-size: 15px;">装饰</a> <a href="/tags/递归/" style="font-size: 15px;">递归</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/进程/" style="font-size: 15px;">进程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/写在工作一年之际/">写在工作一年之际</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/08/装饰模式/">装饰模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/关于递归算法设计的思考/">关于递归算法设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/深入理解进程及线程/">深入理解进程和线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/26/Java的异常处理机制-续、/">Java的异常处理机制-续、</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/Java的异常处理机制/">Java的异常处理机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/工厂模式之抽象工厂/">工厂模式之抽象工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/工厂模式之工厂方法/">工厂模式之工厂方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/工厂模式之简单工厂/">工厂模式之简单工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/如何提升你的能力？给年轻程序员的几条建议/">如何提升你的能力？给年轻程序员的几条建议</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.taoshengxu.com/" title="陶胜旭的博客" target="_blank">陶胜旭的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">春华秋实.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>